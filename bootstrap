#!/bin/sh


fatal ()
{
  echo >&2 "$0: $@"
  exit 1
}

stderr ()
{
    echo >&2 "$0: $@"
}

awk_strverscmp='
  # Use only awk features that work with 7th edition Unix awk (1978).
  # My, what an old awk you have, Mr. Solaris!
  END {
    while (length(v1) || length(v2)) {
      # Set d1 to be the next thing to compare from v1, and likewise for d2.
      # Normally this is a single character, but if v1 and v2 contain digits,
      # compare them as integers and fractions as strverscmp does.
      if (v1 ~ /^[0-9]/ && v2 ~ /^[0-9]/) {
	# Split v1 and v2 into their leading digit string components d1 and d2,
	# and advance v1 and v2 past the leading digit strings.
	for (len1 = 1; substr(v1, len1 + 1) ~ /^[0-9]/; len1++) continue
	for (len2 = 1; substr(v2, len2 + 1) ~ /^[0-9]/; len2++) continue
	d1 = substr(v1, 1, len1); v1 = substr(v1, len1 + 1)
	d2 = substr(v2, 1, len2); v2 = substr(v2, len2 + 1)
	if (d1 ~ /^0/) {
	  if (d2 ~ /^0/) {
	    # Compare two fractions.
	    while (d1 ~ /^0/ && d2 ~ /^0/) {
	      d1 = substr(d1, 2); len1--
	      d2 = substr(d2, 2); len2--
	    }
	    if (len1 != len2 && ! (len1 && len2 && substr(d1, 1, 1) == substr(d2, 1, 1))) {
	      # The two components differ in length, and the common prefix
	      # contains only leading zeros.  Consider the longer to be less.
	      d1 = -len1
	      d2 = -len2
	    } else {
	      # Otherwise, compare as strings.
	      d1 = "x" d1
	      d2 = "x" d2
	    }
	  } else {
	    # A fraction is less than an integer.
	    exit 1
	  }
	} else {
	  if (d2 ~ /^0/) {
	    # An integer is greater than a fraction.
	    exit 2
	  } else {
	    # Compare two integers.
	    d1 += 0
	    d2 += 0
	  }
	}
      } else {
	# The normal case, without worrying about digits.
	if (v1 == "") d1 = v1; else { d1 = substr(v1, 1, 1); v1 = substr(v1,2) }
	if (v2 == "") d2 = v2; else { d2 = substr(v2, 1, 1); v2 = substr(v2,2) }
      }
      if (d1 < d2) exit 1
      if (d1 > d2) exit 2
    }
  }
'

version_compare ()
{
  awk "$awk_strverscmp" v1="$1" v2="$2" /dev/null
  case $? in
    1)  echo '<';;
    0)  echo '=';;
    2)  echo '>';;
  esac
}

# require TOOL REQUIREMENT
# ------------------------
# Test that TOOL exists, and its version is at least REQUIREMENT.
require ()
{
  local version=$($1 --version | sed -n 's/.*[^0-9.]\([0-9][0-9.]*\).*/\1/p;q')
  test x"$version" != x ||
    fatal "$1 is required"
  case $(version_compare "$2" "$version") in
    '>') fatal "$1 $2 or better is required: this is $1 $2";;
  esac
}

# run DIRECTORY COMMAND-LINE
# --------------------------
# "set -e" doesn't work for subshells!
run ()
{
    (
        stderr "$@"
        cd "$1"
        shift
        if ! "$@"; then
            fatal "unexpected failure: $@"
            exit 1
        fi
    )
}


# Failures do matter.
set -e

# Requirements over bootstrap tools.
require autoconf 2.59
require automake 1.9.4

# Generate unit test files.
run milena/tests/unit_test ./build_unit_test.sh $PWD/milena/mln

# Generate milena/dist_headers.mk
run milena ./generate_dist_headers.sh

# Tell what's going on.
set -x

# Install the GNU Build System.
autoreconf -f -v -i

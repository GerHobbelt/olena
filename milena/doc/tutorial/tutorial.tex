\documentclass{report}

%\usepackage{hevea}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{makeidx}
\usepackage{xcolor}
\usepackage{color}
\usepackage{html}
\usepackage{tikz}
\usepackage{pgf}

\newcommand{\img}[4]{
\begin{figure}[ht!]
	\begin{center}
      \includegraphics[width=#2]{figures/#1}
     \caption{#4\label{fig:#1}}
   \end{center}
 \end{figure}
}

\title{Olena -- Tutorial}
\author{LRDE}
\date{}
\makeindex

\definecolor{ccomment}{rgb}{0.5,0,0}
\definecolor{cstring}{rgb}{0,0.32,0.5}
\definecolor{cidentifier}{rgb}{0,0.5,0}
\definecolor{cbg}{rgb}{0.95,0.95,0.95}

%%%LISTINGS SETTINGS
%\begin{latexonly}
\lstset{frameround=fttt}
\lstloadlanguages{[ISO]C++}
\lstset{language=[ISO]C++,
  captionpos=b,
  basicstyle={\small\sffamily}, % normal small footnotesize scriptsize tiny
  commentstyle=\itshape,
  showstringspaces=false,
  numberstyle=\tiny,
  morekeywords={where, auto, concept, concept_map, axiom, late_check, final, abstract},
  morecomment=[s]{/*}{*/},
  backgroundcolor=\color{cbg},
  identifierstyle=\color{black},
  stringstyle=\color{cstring}
}
%\end{latexonly}

% #1 : sub page name
% #2 : sub page title
\newcommand{\doxychapter}[2]{%
\label{#1}
\backslash endhtmlonly%
\backslash page #1 #2%
\backslash htmlonly %
}

% #1 : section name
% #2 : section title
\newcommand{\doxysection}[2]{%
\vspace{1cm}
\label{#1}
\backslash endhtmlonly%
\backslash section #1 #2%
\backslash htmlonly %
}
\newcommand{\doxysubsection}[2]{%
\label{#1}
\backslash endhtmlonly%
\backslash subsection #1 #2%
\backslash htmlonly %
}

\newcommand{\doxysubsubsection}[2]{%
\label{#1}
\backslash endhtmlonly%
\backslash subsubsection #1 #2%
\backslash htmlonly %
}

% #1 - part number (Optional)
% #2 - file name
\newcommand{\doxycode}[2][1]{
\backslash endhtmlonly%
\backslash include #2-#1.cc%
\backslash htmlonly %
}

\newcommand{\doxyrawcode}[1]{
\backslash endhtmlonly%
\backslash include #1.cc.raw%
\backslash htmlonly %
}

\newcommand{\doxyoutput}[1]{
\backslash endhtmlonly%
\backslash include #1.txt%
\backslash htmlonly %
}

% Include file '#1' from a split output.
% #1 - part number (Optional)
% #2 - file name
\newcommand{\doxymoutput}[2][1]{
\backslash endhtmlonly%
\backslash include #2-#1.txt%
\backslash htmlonly %
}

\newcommand{\doxyfigure}[3][1]{
\backslash endhtmlonly%
\backslash image html #2-#1.png%
\backslash htmlonly %
}

\newcommand{\doxyimg}[2]{
\backslash endhtmlonly%
\backslash image html #1.png%
\backslash htmlonly %
}

\newcommand{\doxyref}[1]{
\backslash endhtmlonly%
\backslash ref #1%
\backslash htmlonly %
}

\newcommand{\doxysee}[1]{
\backslash endhtmlonly%
\backslash see #1%
\backslash htmlonly %
}

\newcommand{\tutotoc}[2]{%
\begin{center}%
  \longleftarrow ~Go to \doxyref{#1} \hspace{1cm} | \hspace{1cm} Go to \doxyref{#2}~ \longrightarrow%
\end{center}%
}

\newenvironment{doxymath}
{
%\backslash endhtmlonly%
%\backslash f\$
%\begin{rawtext}
$$
}
{
$$
%\end{rawtext}
%\backslash f\$
%\backslash htmlonly%
}

%\begin{latexonly}
\renewcommand{\doxychapter}[2]{\chapter{#2}\label{#1}}
\renewcommand{\doxysection}[2]{\section{#2}\label{#1}}
\renewcommand{\doxysubsection}[2]{\subsection{#2}\label{#1}}
\renewcommand{\doxysubsubsection}[2]{\subsubsection{#2}\label{#1}}
\renewcommand{\doxycode}[2][1]{\lstinputlisting[frame=single]{examples/#2-#1.cc}}
\renewcommand{\doxyrawcode}[1]{\lstinputlisting[frame=single]{examples/#1.cc.raw}}
\renewcommand{\doxyoutput}[1]{\lstinputlisting[frame=single]{outputs/#1.txt}}
\renewcommand{\doxymoutput}[2][1]{\lstinputlisting[frame=single]{outputs/splitted/#2-#1.txt}}
\renewcommand{\doxyfigure}[3][1]{%
\pgfimage[width=#3]{figures/#2-#1}%
\label{#1}%
}
\renewcommand{\doxyimg}[2]{%
\pgfimage[width=#2]{#1.png}%
\label{#1}%
}
\renewcommand{\doxyref}[1]{\ref{#1}}
\renewcommand{\doxysee}[1]{\ref{#1}}
\renewcommand{\tutotoc}[2]{}
\renewenvironment{doxymath}
{
  $$
}
{
  $$
}

%\end{latexonly}


\newcommand{\code}[1]{%
\textit{#1}%
}
\newcommand{\var}[1]{%
\textit{$#1$}%
}
\newcommand{\val}[1]{%
\textit{#1}%
}
\newcommand{\type}[1]{%
\textit{#1}%
}
\newcommand{\namespace}[1]{%
\textit{#1}%
}
\newcommand{\header}[1]{%
\textit{#1}%
}
\newcommand{\hpath}[1]{%
\textit{#1}%
}

\newcommand{\must}{%
\textbf{must}
}
\newcommand{\should}{%
\textbf{should}
}


\usetikzlibrary{er}

\newcommand{\neighcfour}{%
\begin{latexonly}
\begin{tikzpicture}%
  \tikzstyle{every entity}=[draw=blue!50,fill=blue!20,thick]%
  %center
  \draw (0,0) node[fill=orange!20,draw=orange] {} ;
  %left
  \draw (-0.25,0) node[entity,draw] {};
  %right
  \draw (0.26,0) node[entity,draw] {};%
  %top
  \draw (0,0.25) node[entity,draw] {};%
  %bottom
  \draw (0,-0.25) node[entity,draw] {};%
\end{tikzpicture}%
\end{latexonly}
}

\newcommand{\neighceight}{%
\begin{latexonly}
\begin{tikzpicture}%
  \tikzstyle{every entity}=[draw=blue!50,fill=blue!20,thick]%
  %center
  \draw (0,0) node[fill=orange!20,draw=orange] {} ;
  %left
  \draw (-0.25,0) node[entity,draw] {};
  %right
  \draw (0.26,0) node[entity,draw] {};%
  %top
  \draw (0,0.25) node[entity,draw] {};%
  %bottom
  \draw (0,-0.25) node[entity,draw] {};%
  %Top left
  \draw (-0.25,0.25) node[entity,draw] {};
  %Top right
  \draw (0.26,0.25) node[entity,draw] {};%
  %Bottom left
  \draw (-0.25,-0.25) node[entity,draw] {};%
  %Bottom Right
  \draw (0.26,-0.25) node[entity,draw] {};%
\end{tikzpicture}%
\end{latexonly}
}

\newcommand{\wincfour}{%
\begin{latexonly}
\begin{tikzpicture}%
  \tikzstyle{every entity}=[draw=blue!50,fill=blue!20,thick]%
  %center
  \draw (0,0) node[entity,draw] {} ;
  %left
  \draw (-0.25,0) node[entity,draw] {};
  %right
  \draw (0.26,0) node[entity,draw] {};%
  %top
  \draw (0,0.25) node[entity,draw] {};%
  %bottom
  \draw (0,-0.25) node[entity,draw] {};%

\end{tikzpicture}%
\end{latexonly}
}

\newcommand{\winceight}{%
\begin{latexonly}
\begin{tikzpicture}%
  \tikzstyle{every entity}=[draw=blue!50,fill=blue!20,thick]%
  %center
  \draw (0,0) node[entity,draw] {} ;
  %left
  \draw (-0.25,0) node[entity,draw] {};
  %right
  \draw (0.26,0) node[entity,draw] {};%
  %top
  \draw (0,0.25) node[entity,draw] {};%
  %bottom
  \draw (0,-0.25) node[entity,draw] {};%
  %Top left
  \draw (-0.25,0.25) node[entity,draw] {};
  %Top right
  \draw (0.26,0.25) node[entity,draw] {};%
  %Bottom left
  \draw (-0.25,-0.25) node[entity,draw] {};%
  %Bottom Right
  \draw (0.26,-0.25) node[entity,draw] {};%
\end{tikzpicture}%
\end{latexonly}
}

\newcommand{\dir}[1]{
\textbf{\textit{#1}}
}


\begin{document}

% Doxygen use only - Generate the left menu.
%Write foreword below.
\begin{htmlonly}
\backslash endhtmlonly

\backslash page tutorial Tutorial
- \backslash subpage tuto1
- \backslash subpage tuto2
- \backslash subpage tuto3
- \backslash subpage tuto4
- \backslash subpage tuto5
- \backslash subpage tuto6
- \backslash subpage tuto7

\backslash htmlonly
\end{htmlonly}

\begin{latexonly}
\maketitle

\section*{Copying this document}
Copyright \copyright{} 2008, 2009 LRDE.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with the Invariant Sections
being just ``Copying this document'', no Front-Cover Texts, and no Back-Cover
Texts.

A copy of the license is provided in the file COPYING.DOC.

\tableofcontents
\end{latexonly}

%====================================
\doxychapter{tuto1}{Welcome}

Welcome to Milena's tutorial.





%**************************
\doxysection{tuto1howotlearn}{How to learn Milena}

Milena is only a subpart of Olena but tends to be a large system too.
Therefore it is not possible to present all the functionalities in a
tutorial. 


Milena targets several audiences: \textit{end users}, \textit{designers} and
\textit{providers}. \textit{End users} want to apply and assemble algorithms
to solve image processing, pattern recognition or computer vision problems,
\textit{designers} build new algorithms and \textit{providers} are interested
in developping their own data structures and extend an existing library.


Whatever the kind of user you are, the key to learning how to use Milena is to
become familiar with its palette of objects and the way of combining them.

As an \textit{end user}, you may start with this simple tutorial and the Quick
tour (FIXME: ref). They describe and illustrate the key features of the library.
\textit{End users} getting familiar with Milena and \textit{designers}, should
take a look at the  Quick Reference Guide (FIXME: ref!).
It is a more detailed explanations of the library's features.

\textit{end users} and \textit{designers} may be also interested by all the
examples provided with the documentation and the tutorial. The source code is
available in \hpath{milena/doc/examples} (FIXME: ref) and is usually pointed
out and commented by the documentation.

Taking a look at the test suite is also a good idea. The tests usually focus on
a single functionality and handle several use cases which may overlap your needs.
The test suite is located at \hpath{milena/tests} (FIXME: ref?).

Still not enough information? More information about all the functions is
available in the User HTML documentation (FIXME:ref).
It mainly targets \textit{designers} and \textit{providers}.
The latter may also be interested by the Developer HTML documentation
(FIXME:ref).



%**************************
\doxysection{tuto1obtainingthelib}{Obtaining the library}

There are two ways of getting Milena on the web:
\begin{itemize}
  \item Download a tarball/package from the website,
  \item Checkout the SVN repository.
\end{itemize}

Downloading a package or a tarball is the best choice for a new user. Except
for nightly builds which are packages generated every night from the SVN repository, 
packages and tarballs contain only a released version of Milena. It guaranties a 
certain quality: no building issues, no bugs (ok, maybe some...), \ldots

This tutorial is based on the latest released version of Milena. Therefore,
if you decide to use the SVN version, you may notice different behaviors or results
compared to what it is described in this document. 

Using the SVN version implies some drawbacks: the code might crash, not
compile or produce incorrect results.
Besides, The SVN version is always up to date and you may find new functionalities,
bug fixes and new syntax improvements.
This version targets users familiar with build systems and compilation issues.
We strongly advise you to not use it for production use.



%**************************
\doxysection{tuto1downloading}{Downloading the library}



%download page.

%--------------------------
\doxysubsection{tuto1downloadingsvn}{Downloading from SVN}

First, be sure that SVN is already installed on your system.
Open a terminal and type:

\begin{verbatim}
\$ svn --version --quiet
1.4.6
\end{verbatim}

You should see your version of SVN installed. If you read 'Command not found'
then you need to install SVN.

Usually, systems providing packages reference SVN's package as 'subversion'.

Once you have SVN installed, go to the directory where you woudl like to 
download Olena and create a new directory.

\begin{verbatim}
\$ cd $HOME
\$ mkdir olena
\$ cd olena
\end{verbatim}
     
Then 'checkout' (download) the repository with the following command.

\begin{verbatim}
\$ svn co https://svn.lrde.epita.fr/svn/oln/trunk
\end{verbatim}

Enter the 'trunk' directory.

\begin{verbatim}
\$ cd trunk
\end{verbatim}

You are now ready to configure the directory and install Milena as described 
in section \ref{tuto2}.
We invite you to take a look at the description of the directory structure
(\ref{tuto1dirstruct}.
If you encounter any issues in the installation process or if you have any
question, do not forget to join the mailing lists (\ref{tuto1mailinglists}
and/or use the other documentations ressources (\ref{tuto1documentation}).





%--------------------------
\doxysubsection{tuto1downloadingpackages}{Downloading packaged releases}

%details.

Milena's packages can be downloaded from:

\href{http://www.lrde.epita.fr/Olena/Download}{http://www.lrde.epita.fr/Olena/Download}

On this page you will find the latest and past releases.
Currently, we provide only '.tar.gz' and 'tar.bz2' archives.

Once download, you just need to uncompress the archive.

For the '.tar.gz' archive:
\begin{verbatim}
$ tar zxvf olena-1.0.tar.gz
\end{verbatim}

For the '.tar.bz2' archive:
\begin{verbatim}
$ tar jxvf olena-1.0.tar.bz2
\end{verbatim}

Then, enter the new created directory:
\begin{verbatim}
$ cd olena-1.0
\end{verbatim}


You are now ready to configure the directory and install Milena as described 
in section \ref{tuto2}.
We invite you to take a look at the description of the directory structure
(\ref{tuto1dirstruct}.
If you encounter any issues in the installation process or if you have any
question, do not forget to join the mailing lists (\ref{tuto1mailinglists}
and/or use the other documentations ressources (\ref{tuto1documentation}).



%**************************
\doxysection{tuto1mailinglists}{Join the mailing lists}

Regardless your use of Olena, we strongly advise you to join our mailing lists.
This is the best way to keep up to date about new releases, bug
notifications/fixes and future updates.
This is also a good opportunity to tell us what you would like to find in
Milena and what could be improved.

Currently four mailing-lists are available:

\begin{tabular}{l l}
\textbf{Olena}		& Discussion about the project Olena  \\ 
\textbf{Olena-bugs}	& Bugs from Olena projects	      \\
\textbf{Olena-core}	& Internal list for the Olena project \\
\textbf{Olena-patches}	& patches for the Olena project	      \\
\end{tabular}

You can subscribe to these mailing lists at the following adress:

\begin{center}
\begin{verbatim}
https://www.lrde.epita.fr/mailman/listinfo/
\end{verbatim}
\end{center}

Just click on the name of the mailing list you want to subscribe to and fill
out the form.



%**************************
\doxysection{tuto1dirstruct}{Directory structure}

Milena's directory is composed of several subdirectories. In order to help
you finding what you need, you will find a description of all these
subdirectories.


List of \hpath{milena}'s subdirectories:
\begin{itemize}

\item \dir{apps} --- A full example of a 3D mesh visualization tool. It
  uses milena.

\item \dir{doc} --- THE directory you must know. Contains all the 
  documentation material.

\item \dir{img} --- A set of common test images. They are used in the
  test suite. Feel free to use it in your programs.

\item \dir{mesh} --- A set of 3D meshes. They can be used with the full
  example located in \hpath{milena/apps}.

\item \dir{mln} --- The core of the libray. Contains all the library headers.

\item \dir{tests} --- The test suite. Is it subdivided in sub directories.
  The directory hierarchy respects \hpath{milena/mln}'s. 

\item \dir{tools} --- Small tools written with milena. They can be used as examples.

\end{itemize}



List of \hpath{mln}'s subdirectories:
\begin{itemize}
  \item \dir{accu} --- Set of Accumulators.
  \item \dir{algebra} --- Algebraic structures like vectors or matrices.
  \item \dir{arith} --- Arithmetical operators.
  \item \dir{binarization} --- Routines to binarize an image.
  \item \dir{border} --- Image border related routines.
  \item \dir{canvas} --- Generic canvas. They define generic ways of browsing
  an image, compute data, \dots.
  \item \dir{convert} --- Automatic conversion mechanism.
  \item \dir{core} --- Core of the library. Here you can find the image types,
  the site set types and basic concepts.
  \item \dir{data} --- Routine that modify image data.
  \item \dir{debug} --- Debug related routines.
  \item \dir{display} --- Display images on the screen.
  \item \dir{draw} --- Draw geometric objects in an image.
  \item \dir{essential} --- Set of essential headers for 1,2,3-D manipulations.
  \item \dir{estim} --- Compute data on image values.
  \item \dir{extension} --- Image extension manipulation.
  \item \dir{extract} --- FIXME: extract will be removed and replaced by thru().
  \item \dir{fun} --- Set of functions applying on sites, values, \ldots
  \item \dir{geom} --- Functions related to image geometry.
  \item \dir{graph} --- Graph related routines.
  \item \dir{histo} --- Histogram related functions.
  \item \dir{io} --- I/O related routines.
  \item \dir{labeling} --- Labeling related routines.
  \item \dir{level} --- Point-wise operators on levels.
  \item \dir{linear} --- Linear operators.
  \item \dir{literal} --- Generic image values such as zero, black, white \ldots
  \item \dir{logical} --- Logical operators.
  \item \dir{make} --- Small routines to construct images, windows, \ldots
  \item \dir{math} --- Mathematical functions.
  \item \dir{metal} --- Metalic macros/structures. Static library helping
  developing doing static tests.
  \item \dir{morpho} --- Mathematical morphology.
  \item \dir{norm} --- Norm computation
  \item \dir{opt} --- Optional routines. Routines which may work on a
  specific image type only.
  \item \dir{pw} --- Point-wise image related routines.
  \item \dir{registration} -- Registration related routine.
  \item \dir{set} --- Set related routines.
  \item \dir{subsampling} --- Subsampling related algorithms.
  \item \dir{tag} --- Tag traits.
  \item \dir{test} --- Definition of predicates.
  \item \dir{topo} --- Complex related structures.
  \item \dir{trace} --- Debug trace mechanism.
  \item \dir{trait} --- Internal traits mechanism.
  \item \dir{transform} --- Algorithms based on the level::transform.
  \item \dir{util} --- Various utilitarian classes.
  \item \dir{value} --- Set of value types which can be used in an image.
  \item \dir{win} --- Set of various window kinds.
\end{itemize}


The source code and the material of the documentation is available in \hpath{
milena/doc}.
List of \hpath{doc}'s subdirectories:
\begin{itemize}
\item \dir{examples} --- All the source code of the documentation examples.
\item \dir{benchmark} --- Some benchmarks.
\item \dir{tools} --- Small tools used for generating documentation /
  building examples.

\item \dir{tutorial} --- Tutorial sources.
\item \dir{white\_paper} --- White paper sources.
\item \dir{technical} --- Technical documentation. (DEPRECATED)
\item \dir{ref\_guide} --- Reference guide sources.
\item \dir{figures} --- Reference figures for documentation generation.
\item \dir{outputs} --- Reference outputs for documentation examples.

\end{itemize}




%**************************
\doxysection{tuto1documentation}{Documentation}

This tutorial is not the only documentation of Milena. Other documents are available:

\begin{itemize}
  \item \dir{White paper} --- a small document of few pages presenting the key
  features of the library. It intents to give a big picture of the library.

  \item \dir{Quick tour} --- it aims giving an overview of Milena's possibilities.
  It does not only give the concepts but illustrate them with small sample
  codes.

  \item \dir{Quick reference guide} --- Present in details all the main
  functionalities of Milena.
  Hints and full examples are also provided. The sample codes are commented
  and each concept in the library is detailed. This is the reference document for any 
  \textit{end user} and \textit{algorithm designer}.

  \item \dir{HTML user doc} --- The full documentation of the library. The full
  API is described in details. Each part of the library is classified by
  categories and the source code is directly accessible from the documentation.
  This is the reference document for any \textit{algorithm designer} and/or 
  \textit{provider of data structures}.

  \item \dir{Header files} --- Every object or algorithm is declared in a '.hh' file.
  The documentation is provided as comments in these file. 
\end{itemize}


%**************************
\doxysection{tuto1community}{Community and Support}

Even though Milena is currently developped by the LRDE in EPITA, we are open
for new contributors.

\begin{itemize}
  \item If you are a user, please send us feedback about the library.
  Did you find what you wanted? Do you miss something?

  \item Please report bugs and defect in the API. Mailing lists are the best
  way for reporting that.

  \item Developers, if you write cool open source programs or algorithms with Milena,
  send them to us. We may ship your code with Olena and/or add it to
  our download page.

  \item Educators, if you use Olena for your courses and you are ready to
  share your materials, you can send it to us through our mailing-lists.

  \item We are also interested in partnership or commercial use of Milena.
  If you are interested, contact us directly (\ref{tuto1contacts}).

\end{itemize}


%**************************
\doxysection{tuto1projectstatus}{Project status}

If you want to stay tuned to Milena's development, the best way is probably
the mailing-lists (\ref{tuto1mailinglists}).

There are other ways to get to know what is the status of the project.

\begin{itemize}
\item Olena's trac\\
      \href{https://trac.lrde.org/olena} \\
      Here is the roadmap, the current open tickets/bugs/improvements which
      are taken in consideration. A source browser is also available.

\item Olena's Buildfarm \\
      \href{https://buildfarm.lrde.org/buildfarm/oln/} \\
      The official buildfarm. Every night and after each commit, tests
      are compiled and run. The buildfarm can show you whether it is safe
      to update your svn copy of Milena or not\ldots

\item Test failures
      \href{http://www.lrde.epita.fr/dload/olena/test-failures-daily.html}
      Through this page, you can see exactly which tests do not compile or pass.
      This page is updated every night.

\end{itemize}


%**************************
\doxysection{tuto1briefhistory}{A brief history of Milena}

The Olena project aims at building a scientific computation platform oriented
towards image processing, image recognition, and artificial vision. 
This environment is composed of a high performance generic library (Milena),
a set of tools for shell scripts, together with, in the more distant future,
an interpreter (a la Octave, MatLab etc.) and a visual programming environment. 

The Olena project started in 2000 from a small prototype on 2-D images.
From November 2001 to April 2004, this prototype evolved from version 0.1 to 0.10.
More image types were supported and the level of genericity expected from the
library was partially obtained. During these three years, the prototype was used
to experiment with genericity and to try to meet our objectives.
In February 2007, Olena 0.11 was released to conform modern C++ compilers.
At that time, the code was not enough readable though and the compilation time
was too long.

Since June 2007 up to now, The library of the Olena platform is called Milena
and the library has been rewritten. The programming  paradigm has been
simplified: the code is more readable and the compilation time is acceptable.
The level of genericity still meets our objectives though. 

Milena is now getting ready for being considered as stable and distributable.
The core of the library is getting frozen and we aim at enriching the library,
its documentation and the related tools.


%**************************
\doxysection{tuto1contacts}{Contacts}

If you want to reach us directly, you can contact one of the following people:

\begin{itemize}
  \item Thierry Geraud - Project Manager - thierry.geraud@lrde.epita.fr
\end{itemize}






%====================================
\doxychapter{tuto2}{Installation}

%pre-requis/compatibility
This section describes the installation process of Milena.
Do not forget that Milena is a library, not a program. Therefore, no program
will be installed. 

Milena's examples and tests are compiled on the following platforms:
\begin{itemize}
  \item Apple Tiger Darwin 8, PowerPC, GCC 4.0.1
  \item Apple Leopard Darwin 10.5, X86-64, GCC 4.0.1, 4.2
  \item Linux, i486, GCC 3.3, 4.1, 4.2, 4.3
  \item Linux, x86-64, GCC 4.1
\end{itemize}

We guaranty that Milena compiles on these platforms, e.g. Linux and Unix
platforms. It may compiles on other platforms though but we have not tested.
If you did, and you succeeded, please let us know in order to update this
section.

Milena is known NOT to work with GCC-2.95.


Milena is actively developed under Unix systems. As a result, the build system
is based on the Autotools.
Autotools make sure that every dependencies are resolved before compiling
or installing a program.

Milena is different from usual libraries in a way that nothing needs to be
compiled to use it. The library itself is composed of headers which must be
included when you need them.
Then, your application will be compiled with the parts of the library used in
that program. That's all.

So, why do we have a build system? It is useful for installing the library on
your system, generating the doc and compiling the test suite and the examples.



%**************************
\doxysection{tuto2bootstrap}{Bootstrap (SVN Sources)}

If you got the sources from a package/tarball, you can skip this section. Go
to section \ref{tuto2configure}.

If you downloaded the sources from the SVN repository, you must launch a
script before configuring the build directory. 

Run the following:
\begin{verbatim}
$ cd /my/path/to/olena-1.0
$ ./bootstrap
\end{verbatim}

Running 'bootstrap' can take a while. Some files are generated during this
process.
When it's done, you are ready to configure the build directory.



%**************************
\doxysection{tuto2configure}{Configure}

First, make sure you are at the root directory of the milena source:

\begin{verbatim}
$ cd /my/path/to/olena-1.0
\end{verbatim}

First, create and enter a build directory:
\begin{verbatim}
$ mkdir build
$ cd build
\end{verbatim}

We are now about to configure the build directory. This process will create
the necessary files to compile documentation, examples and tools and prepare the
installation.

\textbf{Important Note}: the Install path prefix must be chosen at this step.
By default, Milena will be installed in /usr/local but you may like to install
it elsewhere. To do so, pass the option \textit{--prefix=/installation/path/prefix}
to the configure script (see below). Replace '/installation/path/prefix' with the
wanted installation path prefix.
  
now, you can run:
\begin{verbatim}
$ ../configure
\end{verbatim}
OR
\begin{verbatim}
$ ../configure --prefix=/installation/path/prefix
\end{verbatim}

The configure script will perform various tests. If there is no dependency
issues, the last lines shown before the prompt are:

\begin{verbatim}
config.status: creating config.h
config.status: executing depfiles commands
$
\end{verbatim}

The build directory is now configured, the library can be installed.



%**************************
\doxysection{tuto2install}{Install}

First, be sure to be in the build directory. If you followed the previous
steps, the build directory should be in the Milena sources root directory. 

\begin{verbatim}
$ cd /my/path/to/olena-1.0/build
\end{verbatim}

If you did not change the default install path prefix, set to 
\hpath{/usr/local}, you will need to have administrator privileges to
perform the installation. Then, you may type:
\begin{verbatim}
$ sudo make install
\end{verbatim}

Otherwise, if you set the install path prefix to a directory own by your
user, simply type:
\begin{verbatim}
$ make install
\end{verbatim}

When the installation is finished, you are done. Milena is installed on your
system. But maybe you would like to build the examples? This is described
in the next section \ref{tuto2optionalcomp}.

A description of the installation content is also available in section
\ref{tuto2installcontent}.



%**************************
\doxysection{tuto2optionalcomp}{Optional compilation}

The library itself does not need to be compiled, therefore installing
Milena does not require compilation.

Though, some examples and tools are provided with the library and must be 
compiled if you want to use them.

\doxysubsection{tuto2examples}{Examples}

Examples are part of the documentation. The sources are located in
\hpath{milena/doc/examples}. 

To compile the examples simply run:
\begin{verbatim}
$ cd /my/path/to/olena-1.0/build/milena/doc/examples
$ make
\end{verbatim}

These examples can produce outputs and images. May be you would like
to run all the examples and take a look at the outputs? To do so, run:
\begin{verbatim}
$ cd /my/path/to/olena-1.0/build/milena/doc/examples
$ make examples
\end{verbatim}

Text and image outputs will be respectively stored in
\hpath{build/milena/doc/outputs} and \hpath{build/milena/doc/figures}.



\doxysubsection{tuto2tools}{Tools}

Few tools are provided with Milena. They can be considered as full program
examples.

Currently two tools are available:
\begin{tabular}{l l}
area\_flooding.cc & FIXME:description \\
\hline
seed2tiling.cc & FIXME:description \\
\end{tabular}

To build these tools, run:
\begin{verbatim}
$ cd /my/path/to/olena-1.0/build/milena/tools
$ make
\end{verbatim}


\doxysubsection{tuto2tests}{Tests}

The test suite used for Milena's development is shipped with the library.

In order to build and run it, just do the following:
\begin{verbatim}
$ cd /my/path/to/olena-1.0/build/milena/tests
$ make check
\end{verbatim}

Running the test suite is memory and CPU consumming and will take a while.


%**************************
\doxysection{tuto2installcontent}{Installation content}

Once installed, Milena's files are located in the installed path prefix
you passed to the configure script or in the default path /usr/local.

In the installed path prefix, Milena's files are located in:

\begin{itemize}
  \item include/mln/ --- The library. All the headers are located here.
  \item share/olena/images --- Mesh sample files which may be used with
  example programs.
\end{itemize}



%====================================
\doxychapter{tuto3}{Getting started with Milena}

** intent

A very simple processing chain; the target is the end-user!

OR (?)
this chain plus a sample tiny generic algorithm

** misc
/!\ step by step...
compilation time w.r.t compilation options (O1, DNDEBUG).




%====================================
\doxychapter{tuto4}{Step 4: Load and save images}

After this step you shoud know how to:
\begin{itemize}
\item load an image,
\item save an image.
\end{itemize}

\vspace{2cm}
Currently, Olena supports the following input image formats:
\begin{itemize}
  \item PBM
  \item PFM
  \item PGM
  \item PNM
  \item PPM 
\end{itemize}

This support is provided through two headers for each type, \header{save.hh} and
\header{load.hh}.
They are located in \hpath{mln/io/$<$image-format$>$/}.

Once the right header is included, the image can be loaded:

\doxycode{ima-load}

If you wan to save an image, simply call the save routine in the proper namespace:
\doxycode{ima-save}

According to the image value type, the proper file format must be chosen.
The supported file formats and their associated image value types are listed
in section \doxyref{imaio}.

\vspace{2cm}
\tutotoc{tuto3}{tuto5}



%====================================
\doxychapter{tuto5}{Step 5: Create your first image}

After this step you should know how to:
  \begin{itemize}
    \item create an image,
    \item display an image in console mode.
  \end{itemize}

\doxysee{tuto2_first_image.cc}


\vspace{2cm}
First, declare an array of bool which will represent the image grid. Each each
cell in this grid is a site and each cell contains a value, \val{true} or
\val{false}.
\doxycode[1]{tuto2_first_image}

From that grid, simply call make::image to get an image initialized with that
data.
\doxycode[2]{tuto2_first_image}
This way of initializing an image is the most common one. However, there are
several other ways described in section \doxyref{imacreate}.


To be sure that the data is correctly initialized, it is possible to display the
image in the standard output using debug::println.
\doxycode[3]{tuto2_first_image}
Output:
\doxyoutput{tuto2_first_image}

Finally, you may want to save the image. Since we use bool as image value, the
PBM format is the best choice. Therefore, we use io::pbm::save.
\doxycode[4]{tuto2_first_image}

The output image looks like the following:
\doxyfigure{tuto2_first_image}{3cm}

In this first step we used a boolean image. Many other value types are available
though. A more detailed description can be found in section
\doxyref{imapossvalues}.

\vspace{2cm}
\begin{center}
  \tutotoc{tuto4}{tuto6}
\end{center}


%====================================
\doxychapter{tuto6}{Step 6: Read and write images}

After this step you should know how to:
  \begin{itemize}
    \item modify/initialize image values,
    \item copy and paste data to an image.
  \end{itemize}


\doxysee{tuto3_rw_image.cc}

\vspace{2cm}
First create an empty color image with a \var{box2d} of 40x40 as domain.
\doxycode[1]{tuto3_rw_image}

If you want to initialize the image with the color red, simply call data::fill as follows:
\doxycode[2]{tuto3_rw_image}

Updating a site value is also possible using \code{operator()} or the
\code{opt::at()} routine. Here we create a blue square of 10x10 pixels from site
(20, 20) to (30, 30).
\doxycode[3]{tuto3_rw_image}
\doxycode[4]{tuto3_rw_image}

The corresponding image:
\doxyfigure[1]{tuto3_rw_image}{3cm}

An image can also be initialized/modified thanks to another image.
Let's load a new image.
\doxycode[5]{tuto3_rw_image}
\var{lena} looks like:
\doxyimg{small-enlarged}{3cm}

If we want to initialize \var{ima} with \var{lena}, we can use \code{data::fill}:
\doxycode[6]{tuto3_rw_image}
Output:
\doxyfigure[2]{tuto3_rw_image}{3cm}
Note that to fill an image with some data, the image domain \must be smaller
or equal to the data.

Likewise, it is possible to paste data from an image to another:
\doxycode[7]{tuto3_rw_image}
Output:
\doxyfigure[3]{tuto3_rw_image}{3cm}

More details can be found in sections \doxyref{imaaccessmodval}, \doxyref{fillop} and \doxyref{pasteop} in
the reference guide.

\vspace{2cm}
\begin{center}
  \tutotoc{tuto5}{tuto7}
\end{center}


%====================================
\doxychapter{tuto7}{Step 7: Regions of interest}

After this step you should know how to:
  \begin{itemize}
    \item take benefit of Olena's genericity,
    \item work only on a region of interest in an image.
  \end{itemize}

\doxysee{tuto4_genericity_and_algorithms.cc}
\vspace{2cm}

In the previous step, we used the routine \code{data::fill} in order to change
the values of an image. It was convenient since we did not need to write any
loop by hand. The problem was that we could not specificy which region to fill
with data. This point leads us to talk about the genericity in Olena.
All along this example we will use the routine \code{data::fill} to illustrate
the possibilities in Olena but note that every image types passed to the
routine in this example could be passed to any algorithm in the library
expecting an image.

One main feature of Olena is to be able to easily work on regions of interest in
images. According to the way a region of interest is defined, a specific image
type is associated. Therefore, each algorithm knows exactly what it is working
on and can behave differently in order to be the most efficient as possible.


All along this step, we will use the following image \var{lena} declared as
follow:

\doxycode[1]{tuto4_genericity_and_algorithms}
\doxyimg{small-enlarged}{3cm}

\code{data::fill} has the following prototype:
\doxyrawcode{fill-proto}
So keep in mind that the first argument we will try to construct in each
example is an image. Note that this image \must be writable, e.g. non-const.


%**************************
\doxysection{tuto4imadomainsiteset}{Image domain restricted by a site set}

Here, we would like to fill a small square with green in \var{lena}. We want
this square to be of size 20x20 and to be located at (20,20).
First, we just need to declare this square which is actually a site set, a
\type{box2d}.
\doxycode[2]{tuto4_genericity_and_algorithms}

Then, we just need to tell \code{data::fill} that we would like to fill the
image \var{lena} but only in this restricted part of the image domain. 
\doxycode[3]{tuto4_genericity_and_algorithms}
Operator '|' can be read 'restricted to'. So below, we wrote 'image \var{lena}
restricted to the region of interest \var{roi}'. Actually this is not directly
\var{lena} which is restricted but its domain.

Note the use of \code{rw()} which is mandatory due to C++ limitations. In C++,
the image created by \code{lena | roi} is \code{const}, e.g. read-only, though
\code{data::fill} expect a \code{non-const} image, e.g. read-write. \code{rw()}
is a workaround to make it read-write.

\begin{center}
  \begin{tabular}{c c c}
    \doxyimg{small-enlarged}{3cm} & ~\huge{$\rightarrow$}~ & \doxyfigure[1]{tuto4_genericity_and_algorithms}{3cm} \\
    \multicolumn{3}{c}{Fill with blue a region of interest defined by a
      \type{box2d}.} \\
  \end{tabular}
\end{center}


%**************************
\doxysection{tuto4imadomainfun}{Image domain restricted by a function}

Sometimes it may not be easy to construct a site set to restrict an image. For
instance, if we would like to fill with green one point out of two in the whole
image, we \textbf{do not want} to write anyloop or construct any site set by hand:
\doxycode[4]{tuto4_genericity_and_algorithms}
\doxycode[5]{tuto4_genericity_and_algorithms}

A shorter way to get exactly the same result, is to define that behavior by a
function. In Milena, a function \code{fun::p2v::chess} is available and does
exactly what we want. Like if it was a site set, simply restrict the image with
the function.

\doxycode[6]{tuto4_genericity_and_algorithms}
\begin{center}
  \begin{tabular}{c c c}
    \doxyimg{small-enlarged}{3cm} & ~\huge{$\rightarrow$}~ & \doxyfigure[2]{tuto4_genericity_and_algorithms}{3cm} \\
    \multicolumn{3}{c}{Fill with green a region of interest defined by a
      \type{Function}.} \\
  \end{tabular}
\end{center}

Note that the functions provided by default in Olena are actually functors.
Thus, they must be constructed like any object which why it is written
\code{lena | fun::p2v::chess()} and not \code{lena | fun::p2v::chess}.


FIXME: Talk about C functions once it is possible in Milena.


%**************************
\doxysection{tuto4imadomainmask}{Image domain restricted by a mask}

Sometimes instead of having a site site or a function defining the regions of
interest we want to work on, we may have a binary image, e.g. a mask. When a
site has its value set to true, it means it will be considered as part of the
masked image domain. Otherwise, it will not.

We construct a mask, \var{mask}. It is initialized with the same geometry properties as
\var{lena}
(domain, extension...).
\doxycode[7]{tuto4_genericity_and_algorithms}

Then, we cannot restrict directly \var{lena} with \var{mask}. These two images
have the same domain, so \code{lena | mask.domain()} would not do anything.
\var{mask} is a classical image, there is not specific type for mask images.
Therefore, we need to express that we want that binary image to be considered as
a mask.
\doxycode[8]{tuto4_genericity_and_algorithms}
\code{pw::value(mask)} makes explicit the fact that \var{mask} is actually a
mask. It means, that for each site of \var{mask}, if its value is set to
\val{true}, then the value associated to this site in \var{lena} must be set
to green.
In this example, we use two images for two different use case: \var{lena} store
the result and the modifications make by the algorithm and \var{mask} allows the
algorithm to know whether it must treat a site or not.

\begin{center}
  \begin{tabular}{c c c c}
    \doxyimg{small-enlarged}{3cm}  &
    \doxyfigure[3]{tuto4_genericity_and_algorithms}{3cm} &
    ~\huge{$\rightarrow$}~ &
    \doxyfigure[4]{tuto4_genericity_and_algorithms}{3cm}  \\
    \multicolumn{4}{c}{Fill with green a region of interest defined by a mask
      image.} \\
  \end{tabular}
\end{center}


%**************************
\doxysection{tuto4imadomainpredicate}{Image domain restricted by a predicate}

Restricting by a predicate is exactly like restricting with a function. We want
to talk about that separately in order to present the small routines available.
They enable the user to write quick and efficient predicate/function.

The two routines are :
\begin{itemize}
  \item pw::value(Image), as seen in a previous section, it is a way to express
  'for each site value in Image'.
  \item pw::cst(Value), it is a way to specify a value to which a site value can
  be compared.
\end{itemize}

Let's see a common use case. 
First, we binarize lena according to specific criterions, only site values with
specific colors are set to true in \var{lena_bw}. Others are set to false. This
image will be used in order to label the components.
Let's consider a labeled image \var{label}. Each component of \var{lena} is labeled with a unique index.
Now, we consider that that our region of interest is a component with id 16.
Then we want to express 'for each site \var{fill} its value in \var{lena} if its
value in \var{label} is equal to 16'.
\doxycode[9]{tuto4_genericity_and_algorithms}


\doxycode[10]{tuto4_genericity_and_algorithms}

\begin{center}
  \begin{tabular}{c c c c}
    \doxyimg{small-enlarged}{3cm}  &
    \doxyfigure[5]{tuto4_genericity_and_algorithms}{3cm} &
    ~\huge{$\rightarrow$}~ &
    \doxyfigure[6]{tuto4_genericity_and_algorithms}{3cm}  \\
    \multicolumn{4}{c}{Fill with green a region of interest defined by its
      label.} \\
  \end{tabular}
\end{center}


%**************************
\doxysection{tuto4component}{Image component restricted to a domain}

\doxycode[11]{tuto4_genericity_and_algorithms}

\begin{center}
  \begin{tabular}{c c c c}
    \doxyimg{small-enlarged}{3cm}  &
%   \doxyfigure[7]{tuto4_genericity_and_algorithms}{3cm} &
    ~\huge{$\rightarrow$}~ &
    \doxyfigure[8]{tuto4_genericity_and_algorithms}{3cm}  \\
    \multicolumn{4}{c}{Fill with green a region of interest defined by its
      label.} \\
  \end{tabular}
\end{center}



\doxycode[12]{tuto4_genericity_and_algorithms}

\begin{center}
  \begin{tabular}{c c c c}
    \doxyimg{small-enlarged}{3cm}  &
    ~\huge{$\rightarrow$}~ &
    \doxyfigure[9]{tuto4_genericity_and_algorithms}{3cm}  \\
    \multicolumn{4}{c}{Fill with green a region of interest defined by its
      label.} \\
  \end{tabular}
\end{center}


\vspace{2cm}
\begin{center}
  \tutotoc{tuto6}{tuto8}
\end{center}


%\end{htmlonly}


\end{document}

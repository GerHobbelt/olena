\documentclass{report}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{makeidx}
\usepackage{xcolor}
\usepackage{color}
\usepackage{html}
\usepackage{tikz}

\newcommand{\img}[4]{
\begin{figure}[ht!]
	\begin{center}
      \includegraphics[width=#2]{figures/#1}
     \caption{#4\label{fig:#1}}
   \end{center}
 \end{figure}
}

\title{Olena - Tutorial
}
\author{LRDE}
\date{}

\definecolor{ccomment}{rgb}{0.5,0,0}
\definecolor{cstring}{rgb}{0,0.32,0.5}
\definecolor{cidentifier}{rgb}{0,0.5,0}
\definecolor{cbg}{rgb}{0.95,0.95,0.95}

%%%LISTINGS SETTINGS
%begin{latexonly}
\lstset{frameround=fttt}
\lstloadlanguages{C++}
\lstset{language=C++}

\lstset{backgroundcolor=\color{cbg},
basicstyle=\bfseries\color{black},
identifierstyle=\color{black},
stringstyle=\color{cstring},
commentstyle=\color{ccomment},
showstringspaces=false,linewidth=14cm}
%end{latexonly}

% #1 : sub page name
% #2 : sub page title
\newcommand{\doxychapter}[2]{%
\label{#1}
\backslash endhtmlonly%
\backslash page #1 #2%
\backslash htmlonly%
}
\newcommand{\doxysection}[2]{%
\label{#1}
\backslash endhtmlonly%
\backslash section #1 #2%
\backslash htmlonly%
}
\newcommand{\doxycode}[1]{
\backslash endhtmlonly%
\backslash include #1.tex%
\backslash htmlonly%
}

%\begin{latexonly}
\renewcommand{\doxychapter}[2]{\chapter{#2}\label{#1}}
\renewcommand{\doxysection}[2]{\section{#2}\label{#1}}
\renewcommand{\doxycode}[1]{\lstinputlisting[frame=single]{samples/#1}}
%\end{latexonly}



\begin{document}

\begin{htmlonly}
\backslash endhtmlonly
\backslash page tutorial Tutorial
- \backslash subpage foreword
- \backslash subpage site
- \backslash subpage siteset
- \backslash subpage image
- \backslash subpage winneigh
- \backslash subpage sitesandco
- \backslash subpage iterators
- \backslash subpage basicops
- \backslash subpage graphes
\backslash htmlonly
\end{htmlonly}

\begin{latexonly}
\tableofcontents
\end{latexonly}

%====================================
\doxychapter{foreword}{Foreword}

%**************************
\doxysection{generality}{Generality}
The following tutorial explains the basic concepts behind Olena and how to use 
the most common objects and routines.
This tutorial includes many code examples and figures. In order to make this
tutorial easier to understand, we will mainly talk about 2D images. This is
not so restrictive since 1D, 3D, $n$D images behave the same way.


Since examples are based on 2D images pixels are actually "points" however we
will call them "sites" which is the most generic name.\newline

Here is also a list of common variable name conventions:
\begin{figure}[ht!]
  \begin{tabular}{|l|l|}
  \hline
  \textbf{Object} & \textbf{Variable name} \\ \hline
  Site & p                            \\ \hline
  Value & v                           \\ \hline
  Neighboor & n                       \\ \hline
  A site close to another site p & q  \\ \hline
  \end{tabular}
\end{figure}

Olena is organized in a namespace hierarchy.  Everything is declared by Olena
within the 'oln::' namespace, and possibly a sub-namespace such as
'oln::arith::' (arithmetic operations on images), 'oln::morpho::' (morphological
operations), etc. Usually, the namespace hierarchy is mapped to the mln
directory tree. For the sake of simplicity, we will neglect the 'oln::'
prefix in all the code examples.

Methods provided by objects in the library are in constant time. If you need
a specific method but you cannot find it, you may find an algorithm which can
compute the information you need.

%**************************
\doxysection{dirtree}{Directory hierarchy}
Olena's tarball is structured as follow:

\begin{itemize}
  \item milena
    \begin{itemize}
%      \item apps :
      \item doc
	\begin{itemize}
	  \item benchmark: set of benchmark.
	  \item examples: more examples.
	  \item oldies: partialy not updated documentation. Not recommended for new users.
	  \item technical: technical doc.
	  \item tutorial: code sample and tutorial.
	\end{itemize}
      \item img: a set of sample images. 
      \item mesh: a full example which uses Olena.
      \item mln: the library. Contains only headers.
      \item tests: test suite.
%      \item tools : 
    \end{itemize}
  \item swilena: Python bindings for Olena.
\end{itemize}


%====================================
\clearpage
\newpage
\doxychapter{site}{Site}

Usually, when talking about images, we think about common images composed of a
set of pixels.
Since Olena is generic, we want to support many kind of images, even images
which are not composed of a set of pixels, such as images having images as sites.

In order to express this genericity, we have the ``site'' concept.
This concept allows us to divide a pixel into two information:
\begin{itemize}
  \item The pixel location, e.g. its coordinates (the site itself).
  \item The value.
\end{itemize}

Let's say we have 2D grid like this:

//FIXME
[dessin de grille 2d, colonnes/lignes numerotees + repere x/y]
Intersection == point 2d == milieu d'un pixel \\

%FIXME: Find a way to get that figure in HTML output.
\begin{latexonly}
\begin{tikzpicture}[scale=2]

\draw[blue!20, thick] (-2, -2) grid [right=0.5cm,above=0.5cm,step=1cm] (3, 3);
\draw[line width=1mm] (-1, -1) grid [step=1cm] (3, 3);
\draw[black,line width=2mm,->] (0, -2) node {y} -- (0, 4);
\draw[black,line width=2mm,->] (-2, 3) node {x} -- (4, 3);

\foreach \x in {-0.5, 0.5, 1.5, 2.5}
  \foreach \y in {-0.5, 0.5, 1.5, 2.5}
    \node at (\x, \y) [fill=blue!30] {};

\draw[black] (2.5, 1.5) -- (4, 2) node {Point2d(2, 2)};
\end{tikzpicture}
\end{latexonly}

On such a regular grid, in 2D, we usually use a 2D point as a site which
means we have the following equivalence:

\begin{center}
  Intersection $\equiv$ point2d (2D site) $\equiv$ center of a pixel
\end{center}

The site does not store any value but refer to an area where we will be able
to read its value.

[Illustration : grille + intersection + pmin() + pmax() + distance entre 2
points en x et en y = 1]\\


%====================================
\clearpage
\newpage
\doxychapter{siteset}{Site set}

Site sets are used:
\begin{enumerate}
  \item To define an image definition domain.
  \item As Site container.
\end{enumerate}

They do not actually store any image value. They only store site information.

Here is a list of all the site set concepts which can be found in
core/site\_set:

\begin{tabular}{|l|p{8cm}|}
\hline
Site set    & Description \\
\hline

p\_array    & site array. \\
\hline
p\_box	    & compact domain defined on a regular grid (in 2D, a rectangle). \\
\hline
p\_if	    & site set verifying a predicate. \\
\hline
p\_queue    & site queue. \\
\hline
p\_run	    & site range. \\
\hline
p\_runs	    & site range set. \\
\hline
p\_set	    & mathematical site set. \\
\hline
p\_vaccess  & site set ordered by value. \\
\hline
p\_edges    & set of graph edges associated to sites. \\
\hline
p\_vertices & set of graph vertices associated to sites.\\
\hline
\end{tabular}

All site sets are iterable. More detailed explanations are available in section \ref{iterators}.

%**************************
\doxysection{sitesetinterface}{Basic interface}
Common basic interface:\\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

bool & is\_valid & - & X & Returns true if it has been initialized. The
default constructor does not initialize it. \\ \hline

bool & has & const P\& p & X &  \\ \hline
\end{tabular} \\


%**************************
\doxysection{sitesetopinterface}{Optional interface}
Site sets may have other methods depending on their type: \\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

size\_t & nsites & - & - & Return the number of sites. \\ \hline
const Box\& & bbox & - & X &  Bounding box. Available only on grid site sets.
\\ \hline
\end{tabular} \\

The previous methods are available depending on the site set. A box
will have the bbox() method since it can be retrived in constant time: a box
is it's own bounding box.

\doxycode{box2d-1}

A p\_array does not have this
method since sites do not have to be adjacent. Maintaining such information, in
order to keep getting the bbox in constant time, would be time and memory
consuming. Instead of providing a method directly in p\_array, an algorithm is
available if this information is needed.
p\_array and box both have a nsites method since the internal structure allows a
constant time retrieval.

\doxycode{box2d-2}



%====================================
\clearpage
\newpage
\doxychapter{image}{Image}


%**************************
\doxysection{definition}{Definition}
An image is composed both of:
\begin{itemize}
\item A function $$
ima : \left\{
  \begin{array}{lll}
    Site &\rightarrow & Value \\
    p & \mapsto & ima(p)
  \end{array}
\right.
$$
\item A site set, also called the "domain".
\end{itemize}

%**************************
\doxysection{imavalues}{Possible value types}

Every image type must take its type of value as parameter.
The value type can be one of the builtins one:
\begin{itemize}
  \item bool
  \item char
  \item unsigned
  \item int
  \item short
  \item long
  \item float
  \item double
\end{itemize}

Other data types are also available:

\begin{tabular}{l|l}
Value type & underlying data type \\ 
\hline
float01\_8 & unsigned long \\
float01\_16 & unsigned long \\
float01\_f & float \\
gl8 & unsigned char \\
gl16 & unsigned short \\
glf & float \\
hsi\_d & double \\
hsi\_f & float \\
int\_s8 & char \\
int\_s16 & short \\
int\_s32 & int \\
int\_u8 & unsigned char \\
int\_u16 & unsigned short \\
int\_u32 & unsigned int \\
rgb16 & mln::util::vec$<$unsigned short$>$ \\
rgb8 & mln::util::vec$<$unsigned char$>$ \\
\end{tabular} \\


All these types are available in mln/value and accessible in the mln::value namespace.
Most of the time, the name of the header which must be included to use one of these data
types is actually ``type\_name.hh". For instance, for rgb8 the header will be
rgb8.hh.



%----------------
\subsection{About value, rvalue and lvalue}

Since the values are of a specific type, it exists a set of all the possible
site values. This set is called "destination" set. It may be iterable and
printable if it is finite and not too huge.

Image types provide a method to access values, namely "operator() const".
Yet, its signature is NOT "value operator()(const site\& p) const"
but "rvalue operator()(const psite\& p) const"

For instance, with I being image2d$<$int\_u8$>$, we have :

\begin{center}
    I::value == int\_u8  but  I::rvalue == const int\_u8\&
\end{center}

so copying the value when the call "f(p)" returns is avoided.
In that case, it is a low-level implementation issue that makes rvalue
be different from value.  In some other cases, the difference can be
more fundamental.  For instance, a proxy is returned so that some extra
code is performed if this value is eventually read.

Likewise, lvalue is also used as return type for methods such as "operator()".
The difference is that lvalue allows the data to be modified.

With I being image2d$<$int\_u8$>$, we have :

\begin{center}
    I::value == int\_u8  but  I::lvalue == int\_u8\&
\end{center}

%**************************
\doxysection{imadomain}{Domain}
The site set contains the sites which compose the image. Sites are based on a
grid so the image depends on that grid as well. 
It means that an image 2D can only be defined by sites based on a 2D grid.
Likewise, an image2d will always have its bouding box defined by a box2d.

Being defined on a grid means that the image can be defined anywhere.
For instance, defining a 2D image with a box2d starting from point (-20, -20)
  to (-3, 5) is completely valid.

The following example shows that the definition domain and the site set are
exactly equivalent.

\doxycode{ima2d-1}
Output:
\doxycode{ima2d-1-output}


To know if a site belongs to an image domain or not, a method ``has()'' is
available.
\doxycode{point-1}
Output:
\doxycode{point-1-output}

Since the notion of site is independent from the image it applies on, we can
form expressions where a site passed to several images:
\doxycode{ima2d-4}


%================================================
\doxysection{imaborder}{Border and extension}
Olena provides extension mechanisms for the
image domain. In the library, both the concept of border and of extension can be encountered.
These concepts are useful in many algorithms and can avoid costly tests while
working with sites located on image edges.

A border is a finite extension provided to a basic image type, such as
image2d. By default, every image is created with a border. The default width is
defined through the global variable border::thickness defined in
mln/border/thickness.hh. Since this is a variable, it can be changed
as shown in the following example.

\doxycode{borderthickness}

Output:

\doxycode{borderthickness-output}

It is important to note that to display the border in the ouput, we use a
special debug function, debug::print\_with\_border. Indeed, the border and the
extension are considered as part of an image only in the algorithms. They are
ignored while saving or printing an image.

Some operations can be performed on the border. The functions are located in
mln/border.\\

%
\bigskip
%
\begin{tabular}{l|p{8cm}}
Routine & Description \\ 
\hline
adjust & Increase the border thickness if it is inferior to a minimum. \\
duplicate & Assign the border with the duplicate of the edges of this image.\\
equalize & Equalize the border of two images so that their size is equal and is
at least a minimum size.\\
fill & Fill the border with a given value.\\
find & Find the border thickness of an image.\\
get & Get the border thickness of an image.\\
mirror & Fills border using nearer pixels with a mirroring effect.\\
resize & Set image border to a specific size.\\
\end{tabular} \\


On morphed images, decribed in section \ref{imamorphed}, the border concept
does not exist and is generalized to the extension concept.
A simple example of a morphed image is a sub-image. A sub image does not have
border nor extension by default.
Thanks to mln/core/routine/extend.hh, an extension can be defined through a
function. This means that the extension can be infinite.
Another point is that an image can be used as extension. For instance, in the
case of a sub-image, you may be interested in extending the sub-image with the
image itself.

[FIXME: schema - voir cahier]

The extension supports the following operations. These functions are located in
mln/extension.\\

%
\bigskip
%
\begin{tabular}{l|p{10cm}}
Routine & Description \\ 
\hline
fill & Fill the extension with a given value.\\
\end{tabular} \\

%----------------
\subsection*{IMPORTANT NOTE}
Many times, you may want to check if a site is part of the image before applying
a treatment. All images provide a method ``has(Site)'' which can return this
information.
Be careful though, calling has() on the image returns true if the given site is
part of the domain \textbf{OR} the the extension/border. All algorithms in Olena
call that method which means that all the algorithms take in consideration the
extension/border if it exists. 

Most of the time, this is the good behavior. For instance, if a rotation of 20
degrees is applied to an image, sites which were not previously in the domain
will be part of it. Thanks to the extension/border, these sites will be
associated to the value they had when they were part of the extension/border.

[Image+bord rotation 20degres, avant, apres]

Sometimes taking the domain in consideration  may not be the expected behavior.
If you do not want to use the extension/border for a specific routine, simply
restrict the image to its domain.

\doxycode{extension-ignore}

Note that:
\begin{center}
ima.domain().has() $\equiv$ (ima | ima.domain()).has()

  and

border::get(ima.domain()) == border::get(ima | ima.domain()) == 0
\end{center}

So it is also valid to write:
\doxycode{extension-ignore2}


%================================================
\doxysection{imamorphed}{Morphed images}
//FIXME: Write it!
// Pas concrete, light, how to concrete
%


%================================================
\doxysection{imainterface}{Interface}

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

I::pvset & domain & - & X - &  \\ \hline
const Value\& & operator() & const point\& p & X & Used for reading. \\ \hline
Value\& & operator() & const point\& p & - & Used for writing. \\ \hline
const P\& & at & unsigned x,
         unsigned y & X & Used for reading. \\ \hline
P\& & at & unsigned x,
         unsigned y & - & Used for writing. \\ \hline
bool & has & const Point\& p & X & \\ \hline
bool & has\_data & - & X & Returns true if the domain is defined. \\ \hline
site\_id & id & - & X & Return the Id of the underlying shared data. \\ \hline
I::vset & destination & - & X & Value set of all the possible site values in this
Image. \\ \hline
site\_set & bbox & - & - & Returns the bounding box of the domain. \\ \hline
site\_set & bbox\_large & - & - & Returns the bouding box of the domain and the
extended domain. \\ \hline

\end{tabular}


%================================================
\doxysection{imaio}{Load and save images}

Currently, Olena supports the following input image formats:
\begin{itemize}
  \item PBM
  \item PFM
  \item PGM
  \item PNM
  \item PPM 
\end{itemize}

This support is provided through two headers for each type, save.hh and load.hh.
They are located in mln/io/$<$image-format$>$/.

Once the right header is included, the image can be loaded:

\doxycode{ima-load}

Note that for the PBM format, you \textbf{MUST} use ``bool'' as value type. 
No special value type is required for other formats though.

\doxycode{ima-save}
%

%================================================
\doxysection{imacreate}{Create an image}

Loading an image is not mandatory, an image can be created from scratch. There
are two possibilites to do so:

\doxycode{ima2d-2}

Img1a has no data and its definition domain is still unset.  We do
not know yet the number of sites it contains. However, it is really useful to
have such an "empty image" because it is a placeholder for the result of some
processing, or another image. Trying to access the site value from an empty
image leads to an error at run-time.
Img1b is defined on a domain but does not have data yet.\\



%================================================
\doxysection{imaaccessmodval}{Access and modify values}

There are several ways to access/modify an image ``ima'':
\begin{itemize}
\item ima.at(x, y, \dots)
\item ima(Site)
\end{itemize}

Most of the time, images can be modified and these two methods can be used both
to read a value and modify it. Both methods are equivalent. 
\doxycode{ima2d-3}
Output:
\doxycode{ima2d-3-output}

Usually, you will want to use the functional way, ``ima(Site)'', more
particularly while iterating over all the sites through an iterator. This use
case will be detailed further in section \ref{iterators}.



%================================================
\doxysection{imasize}{Image size}
Most typical image types owns special methods to retrieve the image size.

\begin{tabular}{l|l}
Image type & Methods \\
\hline
image1d & length()\\
image2d & ncols(), nrows()\\
image3d & ncols(), nrows(), nslis() \\
\end{tabular}

If you need a more generic way to get the size, you can use the routines
provided in mln/geom in the following files:
\begin{itemize}
  \item ncols.hh
  \item nrows.hh
  \item nslis.hh
\end{itemize}

\doxycode{ima-size}
Output:
\doxycode{ima-size-output}



%====================================
\clearpage
\newpage
\doxychapter{winneigh}{Window and neighborhood}

%**************************
\doxysection{winfixme}{FIXME}
FIXME

\doxycode{ima2d-display-1}



%====================================
\clearpage
\newpage
\doxychapter{sitesandco}{Sites, psites and dpoints}


%**************************
\doxysection{sitessite}{Need for site}

As we have seen before, an image is defined on a grid. It has associated
data and a site set which defines the domain of the image on that grid.
Usually, we need to access a value by its coordinates. With default images it
can be done easily, at no cost.

Example with an image2d:
\doxycode{ima2d-display-1}

The site x is the point (0, 1).  The image values are stored in a
multi-dimensional array. The point coordinates can be used directly. The site
(0, 1) \textbf{is} the point (0, 1) and the data is stored at row 0 and column
1.

Here we have:

  I::site == I::psite == point2d

where, roughly, point2d = \{ row, column \}.

%**************************
\doxysection{sitespsite}{Need for psite}

Sometimes, accessing a value in constant-time complexity, O(1), is not
possible with a site object.

Let's have a small example. Define a function returning a value for a given
point:
\clearpage
\doxycode{fun-p2v-1}

So, for each point having (0, x) as coordinate, this function will return 8,
otherwise it will be 9.

Then, define a p\_array with few point2d:
\doxycode{parray-append}

Now, create a point-wise image from this function and this p\_array:
\doxycode{mln_var-1}

Ima is actually that image:
\doxycode{ima2d-display-2}

However, in memory, since it is based on a p\_array, sites are stored in a
vector.

The site x is the point (3, 7) which corresponds to the cell 1 in the p\_array.
\doxycode{parray-display-1}

Obviously, we cannot check in constant time whether the site x, point2d here,
is part of that image or not: knowing the point coordinates is not enough.
That's why we need a different mechanism in order to access this information:
the psites.

Here we have:

  I::site $==$ point2d  but  I::psite $==$ pseudo\_site$<$point2d$>$

where, roughly, pseudo\_site$<$point2d$>$ $=$ \{ i\_in\_p\_array, p\_array\_ptr
\}.

Psites contains all the needed information to access the values in
constant-time.

%**************************
\doxysection{sitespsitensite}{From psite to site}

In the last example there was an image of type I such as I::site != I::psite. 
In that case, an object of type I::psite is actually convertible towards an
object of type I::site.  Furthermore, a psite shall behave as if it was a
site.

Design note: it seems impossible to offer through the interface of
some psite what is expected from its corresponding site.  For instance, when a
site has a given feature, say a method "m", then this
method has to appear in the psite interface. However, thanks to
inheritance, we fetch an interface and an implementation that delegates
to the site.

For instance, in the last example, I::psite has a method ::row() because
I::site, point2d, provides such a method.

How it works: a psite inherits from internal::site\_impl$<$site$>$ which is
specialized for every site type; for instance, internal::site\_impl$<$point2d$>$
owns the method "coord row() const" which is defined as
"return exact(this)-$>$to\_site().row()"

%**************************
\doxysection{sitesdpoint}{Need for dpoint}
//FIXME



%====================================
\clearpage
\newpage
\doxychapter{iterators}{Iterators}

Each container object in Olena like site sets or images have iterators.
The iteration mechanism for images is directly derived from the mechanism
for site sets.

There are usually three kinds:
\begin{itemize}
\item \textbf{fwd\_iter}, depends on the container,
\item \textbf{bkd\_iter}, iterates like forward but to the opposite way,
\item \textbf{iter}, usually the same as fwd\_iter. It is guaranteed to
iterate all over the elements.
\end{itemize}
Every iterable object have these three kinds of iterator. There are all
bidirectional containers.
Whatever the iterator used, the basic iterator has the only property of
browsing every site once.

The iterator type name depends on the data pointed by it: \\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Data type & Iterator Names \\ \hline
Site & fwd\_piter, bkd\_piter, piter \\ \hline
Value & fwd\_viter, bkd\_viter, viter \\ \hline
\end{tabular} \\

As you may have noticed, according to the data type, the word "iter" is prefixed
by the usual name variable used for that data type. Sites variables are usually
called 'p' so the proper iterator is "piter". (See the foreword)\\


An iterator has the following interface: \\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

void & start & - & - & \\ \hline
void & next & - & - & \\ \hline
bool & is\_valid & - & - & Return false if created with the default
constructor and not associated to a proper container.\\ \hline
\end{tabular} \\


Example of different forward iterations:
\begin{itemize}
  \item box2d: from top to bottom then from left to right.
  \item p\_array$<$point2d$>$: from left to right.
\end{itemize}

A for\_all() macro is available to iterate over all the sites: \\

\doxycode{forall-piter-1}

Note that when you declare an iterator, prefer using the "mln\_*iter" macros.
They resolve the iterator type automatically from the given container type
passed as parameter. These macros can be used with any container like images or
site sets.

Here follow an example with the implemantions of the most basic routines which use the for\_all
loop: fill and paste.

\doxycode{fill}

\doxycode{paste}



%================================================
\clearpage
\doxychapter{imamemmgmt}{Memory management}

In the Olena library, all image types behave like image2d:
\begin{itemize}
\item An "empty" image is actually a mathematical variable.

      $\rightarrow$ just think in a mathemetical way when dealing with images;

\item No dynamic memory allocation/deallocation is required.
    the user never has to use "new / delete" (the C++ equivalent for the C
    "malloc / free") so she does not have to manipulate pointers or to directly
    access memory.
    
    $\rightarrow$ Olena prevents the user from making mistakes;

\item Image data/values can be shared between several variables and the memory
    used for image data is handled by the library.
    
    $\rightarrow$ Memory management is automatic.
\end{itemize}

%----------------
\subsection*{Exemple with image2d}

Images do not actually store the data in the class. Images store a pointer
to an allocated space which can be shared with other objects. Once an image is
assigned to another one, the two images share the same data so they have the
same ID and point to the same memory space.
Therefore, assigning an image to another one is NOT a costly operation. The new
variable behaves like some mathematical variable.  Put differently it is just a
name to designate an image:
\doxycode{ima2d-5}

If a deep copy of the image is needed, a method clone() is available:
\doxycode{ima2d-6-clone}



%====================================
\clearpage
\newpage
\doxychapter{basicops}{Basic operations}
//FIXME : illustrer

%**************************
\doxysection{basicroutines}{Basic routines}
\begin{tabular}{l|p{8cm}}
\hline
Routine name & Description \\ \hline
level::clone() & creates a deep copy of an object. Any shared data is
duplicated. \\ 

level::fill() & fill an object with a value. \\ 

level::paste() & paste object data to another object. \\ 

labeling::blobs() & find and label the different components of an image. \\

*::compute() & compute an accumulator on specific elements. \\
\hline
\end{tabular} \\

%**************************
\doxysection{fillop}{Fill}
First, create an image:
\doxycode{ima2d-decl-1}

Memory has been allocated so data can be stored but site values
have not been initialized yet.  So we fill imga with the value 'a':

\doxycode{fill-call-1}

The "fill" algorithm is located in the sub-namespace "level" since this
algorithm deals with the "level" of site values.

Note that the term "level" refers to the fact that an image can be considered as
a landscape where the elevation at a particular location/site is given by
the corresponding site value.

The full name of this routine is "oln::level::fill".  To access to a particular
algorithm, the proper file shall be included. The file names of algorithms
strictly map their C++ name; so oln::level::fill is defined in the file
"oln/level/fill.hh".

%----------------
\subsection*{Note}
Most algorithms in Olena are constructed following the classical scheme: "output
algo(input)", where the input image is only read. However some few algorithms
take an input image in order to modify it.  To enforce this particular feature,
the user shall explicitly state that the image is provided so that its data is
modified "read/write". The algorithm call shall be "level::fill(ima.rw(),
val)". When forgetting the "rw()" call it does not compile.


%**************************
\doxysection{pasteop}{Paste}
We then define below a second image to play with.  As you can see this image has
data for the sites (5, 5) to (14, 14) (so it has 100 sites).  

\doxycode{paste-call-1}
Output:
\doxycode{paste-call-1-output}

Before pasting, the couple of images looked like:

//FIXME : ajouter des zolies zimages.

so after pasting we get:

//FIXME : ajouter des zolies zimages again.

%----------------
\subsection*{Note}
With this simple example we can see that images defined on different domains (or
set of sites) can interoperate.  The set of sites of an image is defined and
can be accessed and printed. The following code:

\doxycode{domain-display-1}

Gives:
\doxycode{domain-display-out-1}

The notion of site sets plays an important role in Olena. Many tests are
performed at run-time to ensure that the program is correct.

For instance, the algorithm level::paste tests that the set of sites of imgb
(whose values are to be pasted) is a subset of the destination image.



%====================================
\doxysection{blobs}{Blobs}
//FIXME: write it!

%**************************
\doxysection{compute}{Compute}

There are several flavour of the compute routine, depending on what the kind of
elements it computes.

\begin{tabular}{l|p{8cm}}
\hline
labeling::compute() & compute an accumulator for each component in a labeled
image. \\

level::compute() & compute an accumulator on the values of an image.  \\
\end{tabular}

An accumulator is a special object accumulating data while iterating all over
the image values or sites. Hereby follows a list of accumulators available in
Olena.

%----------------
\subsection*{Accumulators on sites}
\begin{tabular}{l|p{8cm}}
Name | Description \\
\hline
bbox & \\
count\_adjacent\_vertices & \\
count & \\
height & \\
volume & \\
\end{tabular}

%----------------
\subsection*{Accumulators on values}
\begin{tabular}{l|p{8cm}}
Name | Description \\
\hline
histo & \\
max & \\
max\_h & \\
mean & \\
median\_alt & \\
median\_h & \\
min & \\
min\_h & \\
min\_max & \\
rank\_bool & \\
rank & \\
rank\_high\_quant & \\
sum & \\
\end{tabular}

%----------------
\subsection*{Accumulators on values}
\begin{tabular}{l|p{8cm}}
Name | Description \\
\hline
pair & \\
p & \\
tuple & \\
v & \\
\end{tabular}

//FIXME: write it!


%====================================
\doxysection{partima}{Working with parts of an image}

Sometime it may be interesting to work only on some parts of the image or to
extract only a sub set of that image. Olena enables that thoughout out the
operator '$|$'.

Three kinds of that operator exist:\\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Prototype & Comments \\ \hline

Image $|$ Sub Domain & Create a new image.\\ \hline
Image $|$ Function\_p2b & Do not create a new image but create a morpher.\\
\hline
Function\_p2v $|$ Sub Domain & Do not create a new image but create a morpher.\\
\hline
\end{tabular} \\

A Sub Domain can be a site set, an image or any value returned by this
operator.
For a given site, Function\_p2v returns a Value and Function\_p2b returns a
boolean. These functions. are actually a sort of predicate. A common
function\_p2v is pw::value(Image). It returns the
point to value function used in the given image. C functions can also be used as
predicate by passing the function pointer.

You can easily get a function\_p2b by comparing the value returned 
by a function\_p2v to another Value.
The following sample codes illustrate this feature.

In order to use C functions as predicate, they must have one of the following
prototype if you work on 2D images:
\doxycode{predicate-1}
Of course, you just need to change the point type if you use another image
type. For instance, you would use point3d with 3D images.
The returned value type V for function\_p2v depends on the image value type.
With image2d$<$int$>$, V would be int.

In this section, all along the examples, the image "ima" will refer to the
following declaration:
\doxycode{ima2d-decl-2}

A simple example is to fill only a part of an image with a specific value:
\doxycode{fill-part-1}

The two next examples extract a specific component from an image and fill a new
image with red only in the extracted component's domain.
\doxycode{fill-part-2}

The previous example can be written more quickly:
\doxycode{fill-part-3}

Here is an example using a C function:
\doxycode{fun-p2b-1}

\doxycode{ima2d-restricted-display-1}

%
\medskip
%
%
%----------------
\subsection*{Important note}
When writing:

\doxycode{ima2d-restricted-1}

sub\_D must be included in ima.domain().

Let's have an image, \textit{imab}, like this:
\doxycode{ima2d-display-output-1}

Extract a sub image from \textit{imab} with sites having their value set to 1.
\doxycode{mln_var-2}
Then, \textit{imab1} looks like:
\doxycode{ima2d-display-output-2}

Now, if we want to extract a sub image it may fail, depending on the site set
used:
\doxycode{ima2d-restricted-2}

If you do not want this constraint, you may want to use an alternative
operator:
\doxycode{ima2d-restricted-3}

In that case there is no restriction on the domain at all and the following example will work.
\doxycode{mln_var-3}

With this operator, an intersection is applied on the image domain and the
site set.



%====================================
\newpage
\clearpage
\doxychapter{graphes}{Graphes and images}

//FIXME: REWRITE

%**************************
\doxysection{graphdesc}{Description}
Olena enables the possibility of using graphes with images.
Graphes can help you to handle directly parts of an image and represent their
relationship.
Specific data can be associated to each vertex and/or edges.

//FIXME: Add more explanations?

%**************************
\doxysection{graphexample}{Example}

First, create a graph which looks like the following:

\doxycode{graph-output-1}

First we need to add vertices:

\begin{lstlisting}
util::graph g;

for (unsigned i = 0; i < 5; ++i)
  g.add_vertex () // Associated to vertex 'i';
\end{lstlisting}

Finally, populate the graph with edges:
\begin{lstlisting}
g.add_edge(0, 1); // Associated to edge 0.
g.add_edge(1, 2); // Associated to edge 1.
g.add_edge(1, 3); // Associated to edge 2.
g.add_edge(3, 4); // Associated to edge 3.
g.add_edge(4, 2); // Associated to edge 4.
\end{lstlisting}

Now there is a graph topology and we want to associate elements of this graph
to a site in the image.
The idea is to use specific site sets such as p\_vertices and p\_edges.
Let's associate the vertices with sites. To do so we need to create a functor
which for a given vertex returns a site.

\begin{lstlisting}[frame=single]
struct assoc_fun : public Function_v2v< assoc_fun >
{
  typedef const point2d& result;

  inline
  const point2d& operator()(const vertex<graph::util>& v) const
  {
    ...
  }

};
\end{lstlisting}

Then declare a p\_vertices:
\begin{lstlisting}[frame=single]
p_vertices<util::graph, assoc_fun> pv(g, assoc_fun());
\end{lstlisting}

Thanks to the p\_vertices there is now a mapping between vertices and sites.
We may like to map data to it. The idea is to provide a function which returns the associated data
according to the site given as parameter. Combining this function and the
p\_vertices, we get an image. Since this is an image, you can use it with algorithms and for\_all loops.

\begin{lstlisting}[frame=single]

template <typename I>
mln_rvalue(I) my_data_fun(mln_site(I) site)
{
  ...
}

void my_fun()
{
  ...
  // Constructs an image 
  mln_VAR(graph_vertices_ima, my_data_fun | pv);

  //Prints each vertex
  mln_piter p(graph_vertices_ima);
  for_all(p)
    std::Cout << p << std::endl;
  ...
}
\end{lstlisting}

Note that like any image in Olena, graph images share their data. Therefore,
while constructing a graph image from a graph and a function, the graph is not
copied and this is NOT a costly operation.

Like other images, graph images also have an overloaded operator() to access the
data associated to a vertex or an edge.
\begin{lstlisting}
  //Prints each edge's associated value.
  mln_piter p(graph_edge_ima);
  for_all(p)
    std::cout << graph_edge_ima(p) << std::endl;

  //Prints each vertex's associated value.
  mln_piter p(graph_vertex_ima);
  for_all(p)
    std::cout << graph_vertex_ima(p) << std::endl;
\end{lstlisting}

Of course, creating a graph image is not necessary and you can work directly
with the graph and container/function mapping indexes and data.

\begin{lstlisting}
// Iterator on vertices.
mln_Viter V(g);

// Prints each vertex and its associated value.
for_all(V)
{
  std::cout << V << " : " << my_data_fun(V) << std::endl;
}
\end{lstlisting}

Graphes have iterators like any other site sets and also provide
specific iterators in order to iterate over graphes in a more intuitive way.

\begin{lstlisting}
// Iterator on vertices.
mln_Viter V(g);

// Iterator on V's edges.
mln_Eiter n(g, V);

// Prints the graph
// List all edges for each vertex.
for_all(V)
{
  std::cout << V << " : ";
  for_all(n)
    std::cout << n << " ";
  std::cout << std::endl;
}

// Iterator on edges.
mln_Eiter E(g);

// Iterator on vertices adjacent to E.
mln_Viter n(g, E);

// Prints the graph
// List all adjacent vertices for each edge.
for_all(E)
{
  std::cout << E << " : ";
  for_all(n)
    std::cout << n << " ";
  std::cout << std::endl;
}
\end{lstlisting}

//FIXME talk about p\_vertices and p\_edges.

\end{document}

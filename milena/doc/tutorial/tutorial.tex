\documentclass{report}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{makeidx}
\usepackage{xcolor}
\usepackage{color}
\usepackage{html}

\newcommand{\img}[4]{
\begin{figure}[ht!]
	\begin{center}
      \includegraphics[width=#2]{figures/#1}
     \caption{#4\label{fig:#1}}
   \end{center}
 \end{figure}
}

\title{Olena - Tutorial
}
\author{LRDE}
\date{}

\definecolor{ccomment}{rgb}{0.5,0,0}
\definecolor{cstring}{rgb}{0,0.32,0.5}
\definecolor{cidentifier}{rgb}{0,0.5,0}
\definecolor{cbg}{rgb}{0.95,0.95,0.95}

%%%LISTINGS SETTINGS
\lstset{frameround=fttt}
\lstloadlanguages{C++}
\lstset{language=C++}

%\lstset{backgroundcolor=\color{black},
%basicstyle=\bfseries\color{white},
%identifierstyle=\color{green},
%stringstyle=\color{yellow},
%commentstyle=\color{red},
%showstringspaces=false,linewidth=14cm}

\lstset{backgroundcolor=\color{cbg},
basicstyle=\bfseries\color{black},
identifierstyle=\color{black},
stringstyle=\color{cstring},
commentstyle=\color{ccomment},
showstringspaces=false,linewidth=14cm}

\newenvironment{doxycode}
{% This is the begin code
\begin{latexonly}%
\begin{lstlisting}[frame=single]%
\end{latexonly}%
\begin{htmlonly}%
\backslash code%
\end{htmlonly}%
}
{%
\begin{htmlonly}%
\backslash endcode%
\end{htmlonly}%
\begin{latexonly}%
\end{lstlisting}%
\end{latexonly}%
}




\begin{document}

\tableofcontents

\chapter*{Foreword}

The following tutorial explains the basic concepts behind Olena and how to use 
the most common objects and routines.
This tutorial includes many code examples and figures. In order to make this
tutorial easier to understand, we will mainly talk about 2D images. This is
not so restrictive since 1D, 3D, $n$D images behave the same way.


Since examples are based on 2D images pixels are actually "points" however we
will call them "sites" which is the most generic name.\newline

Here is also a list of common variable name conventions:
\begin{figure}[ht!]
  \begin{tabular}{|l|l|}
  \hline
  \textbf{Object} & \textbf{Variable name} \\ \hline
  Site & p                            \\ \hline
  Value & v                           \\ \hline
  Neighboor & n                       \\ \hline
  A site close to another site p & q  \\ \hline
  \end{tabular}
\end{figure}

Olena is organized in a namespace hierarchy.  Everything is declared by Olena
within the 'oln::' namespace, and possibly a sub-namespace such as
'oln::arith::' (arithmetic operations on images), 'oln::morpho::' (morphological
operations), etc. Usually, the namespace hierarchy is mapped to the mln
directory tree. For the sake of simplicity, we will neglect the 'oln::'
prefix in all the code examples.

Methods provided by objects in the library are in constant time. If you need
a specific method but you cannot find it, you may find an algorithm which can
compute the information you need.

\clearpage
\newpage
\chapter{Site}

Usually, when talking about images, we think about common images composed of a
set of pixels.
Since Olena is generic, we want to support many kind of images, even images
which are not composed of a set of pixels, such as images of images.

In order to express this genericity, we have the ``site'' concept.
This concept allows us to divide a pixel into two information:
\begin{itemize}
  \item The coordinates (the site itself).
  \item The value.
\end{itemize}

Let's say we have 2D grid like this:

//FIXME
[dessin de grille 2d, colonnes/lignes numerotees + repere x/y]
Intersection == point 2d == milieu d'un pixel \\

On a regular grid like this, in 2D, we usually use a 2D point as a site which
means we have the following equivalence:

\begin{center}
  Intersection $\equiv$ point2d (2D site) $\equiv$ center of a pixel
\end{center}

The site does not store any value but refer to an area where we will be able
to read its value.


\clearpage
\newpage
\chapter{Site set}

Site sets are used:
\begin{enumerate}
  \item To define an image definition domain.
  \item As Site container.
\end{enumerate}

They do not actually store any image value. They only store site information.

Here is a list of all the site set concepts which can be found in
core/site\_set:

\begin{tabular}{|l|p{8cm}|}
\hline
Site set    & Description \\
\hline

p\_array    & site array. \\
\hline
p\_box	    & compact domain definde on a regular grid (in 2D, a rectangle). \\
\hline
p\_if	    & site set verifying a predicate. \\
\hline
p\_queue    & site queue. \\
\hline
p\_run	    & site range. \\
\hline
p\_runs	    & site range set. \\
\hline
p\_set	    & mathematical site set. \\
\hline
p\_vaccess  & site set ordered by value. \\
\hline
p\_edges    & set of graph edges associated to sites. \\
\hline
p\_vertices & set of graph vertices associated to sites.\\
\hline
\end{tabular}

\section{Basic interface}
Common basic interface:\\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

bool & is\_valid & - & X & Returns true if it has been initialized. The
default constructor does not initialize it. \\ \hline

bool & has & const P\& p & X &  \\ \hline
\end{tabular} \\


\section{Optional interface}
Site sets may have other methods depending on their type: \\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

size\_t & nsites & - & - & Return the number of sites. \\ \hline
const Box\& & bbox & - & X &  Bounding box. Available only on grid site sets.
\\ \hline
\end{tabular} \\

The previous methods are available depending on the site set. A box
will have the bbox() method since it can be retrived in constant time: a box
is it's own bounding box.

\begin{lstlisting}[frame=single]
  box2d b(2,3);

  // The bbox can be retrived in constant time.
  std::cout << b.bbox() << std::endl;

  // nsites can be retrieved in constant time.
  std::cout << "nsites = " << b.nsites() << std::endl;
\end{lstlisting}

A p\_array does not have this
method since sites do not have to be adjacent. Maintaining such information, in
order to keep getting the bbox in constant time, would be time and memory
consuming. Instead of providing a method directly in p\_array, an algorithm is
available if this information is needed.
P\_array and box both have a nsites method since the internal structure allow a
constant time retrieval.

%\begin{doxycode}
\begin{lstlisting}[frame=single]
  p_array<point2d> arr;

  // The bbox is computed thanks to bbox() algorithm.
  box2d box = geom::bbox(arr);
  std::cout << box << std::endl;

  // p_array provides nsites(),
  // it can be retrieved in constant time.
  std::cout << "nsites = " << arr.nsites() << std::endl;
\end{lstlisting}
%\end{doxycode}


\clearpage
\newpage
\chapter{Image}

An image is composed both of:
\begin{itemize}
\item A function $$
ima : \left\{
  \begin{array}{lll}
    Site &\rightarrow & Value \\
    p & \mapsto & ima(p)
  \end{array}
\right.
$$
\item A site set, also called the "domain".
\end{itemize}

\section{About value, rvalue and lvalue}

Since the values are of a specific type, it exists a set of all the possible
site values. This set is called "destination" set. It may be iterable and
printable if it is finite and not too huge.

Image types provide a method to access values, namely "operator() const".
Yet, its signature is NOT "value operator()(const site\& p) const"
but "rvalue operator()(const psite\& p) const"

For instance, with I being image2d$<$int\_u8$>$, we have :

\begin{center}
    I::value == int\_u8  but  I::rvalue == const int\_u8\&
\end{center}

so copying the value when the call "f(p)" returns is avoided.
In that case, it is a low-level implementation issue that makes rvalue
be different from value.  In some other cases, the difference can be
more fundamental.  For instance, a proxy is returned so that some extra
code is performed if this value is eventually read.

Likewise, lvalue is also used as return type for methods such as "operator()".
The difference is that lvalue allows the data to be modified.

With I being image2d$<$int\_u8$>$, we have :

\begin{center}
    I::value == int\_u8  but  I::lvalue == int\_u8\&
\end{center}

\section{Domain}
The site set contains the sites which compose the image. Sites are based on a
grid so the image depends on that grid as well. 
It means that an image 2D can only be defined by sites based on a 2D grid.
Likewise, an image2d will always have its bouding box defined by a box2d.

Being defined on a grid means that the image can be defined anywhere.
For instance, defining a 2D image with a box2d starting from point (-20, -20)
  to (-3, 5) is completely valid.

The following example shows that the definition domain and the site set are
exactly equivalent.

\begin{lstlisting}[frame=single]
  box2d b(-2,3, 3,-5); // Define a box2d from (-2,3) to (3,-5).
  image2d<int> ima(b); // Define the domain of the image.

  cout << b << std::endl; // Display b

  cout << ima.domain() << std::endl; // Display b too
\end{lstlisting}


\section{Border and extension}
// FIXME: COMPLETELY WRONG!!!
// FIXME: Tell that the user can disable the border/extension: foo(ima | ima.domain())
An image has a virtual border which is defined thanks to its domain. The
 border is virtual since the image can have an extended domain as well.
That one is optional, it defines sites outside the virtual border which is
useful in algorithms when working with sites being part of the domain but close
to the borders. The extended domain can be defined thanks to a function, an
image or a site set.

//FIXME ADD FIGURE

\section{Morphed images}
//FIXME: Write it!
// Pas concrete, light, how to concrete

\section{Sample code}
In order to create a 2D image, you have two possibilites:
\begin{lstlisting}[frame=single]
  // which builds an empty image;
  image2d<int> img1a;
  // which builds an image with 6 sites
  image2d<int> img1b(box2d(2, 3));
\end{lstlisting}

The empty image has no data and its definition domain is still unset.  We do
not know yet the number of sites it contains. However, it is really useful to
have such an "empty image" because it is a placeholder for the result of some
processing, or another image. Trying to access the site value from an empty
image leads to an error at run-time.

The following example illustrates how to map data to a site throughout the
image.

\begin{lstlisting}[frame=single]
  box2d b(2,3);
  image2d<int> ima(b);
  point2d p(1, 2);

  // Associate '9' as value for the site/point2d (1,2).
  // The value is returned by reference and can be changed.
  ima.at(1,2) = 9;
  cout << ima(p) << std::endl; // prints 9

  ima(p) = 2; // The value is returned by reference
              // and can be changed as well.
  cout << ima(p) << std::endl; // prints 2
\end{lstlisting}


To know if a point belongs to an image domain or not, we can run this short
test:
\begin{lstlisting}[frame=single]
point2d p(9, 9);

// which gives 'true'.
std::cout << (imga.has(p) ? "true" : "false") << std::endl;
\end{lstlisting}

Since the notion of site is independent from the image it applies on, we can
form expressions where p is used on several images:
\begin{lstlisting}[frame=single]
// At index (9, 9), both values change.
imga(p) = 'M', imgb(p) = 'W';

debug::println(imga);
debug::println(imgb);
\end{lstlisting}


Images do not actually store the data in the class. Images store a pointer
to an allocated space which can be shared with other objects. Once an image is
assigned to another one, the two images share the same data so they have the
same ID and point to the same memory space.
Therefore, assigning an image to another one is NOT a costly operation. The new
variable behaves like some mathematical variable.  Put differently it is just a
name to designate an image:
\begin{lstlisting}[frame=single]
  image2d<int> ima1(box2d(2, 3));
  image2d<int> ima2;
  point2d p(1,2);

  ima2 = ima1; // ima1.id() == ima2.id()
               // and both point to the same memory area.

  ima2(p) = 2; // ima1 is modified as well.

  // prints "2 - 2"
  std::cout << ima2(p) << " - " << ima1(p) << std::endl;
  // prints "true"
  std::cout << (ima2.id() == ima1.id()) << std::endl;
\end{lstlisting}

If a deep copy of the image is needed, a method clone() is available:
\begin{lstlisting}[frame=single]
  image2d<int> ima3 = ima1.clone(); // Makes a deep copy.

  ima3(p) = 3;

  // prints "3 - 2"
  std::cout << ima3(p) << " - " << ima1(p) << std::endl;
  // prints "false"
  std::cout << (ima3.id() == ima1.id()) << std::endl;
\end{lstlisting}

[Illustration : grille + intersection + pmin() + pmax() + distance entre 2
points en x et en y = 1]\\

In the Olena library, all image types behave like image2d:
\begin{itemize}
\item An "empty" image is actually a mathematical variable.

      $\rightarrow$ just think in a mathemetical way when dealing with images;

\item No dynamic memory allocation/deallocation is required.
    the user never has to use "new / delete" (the C++ equivalent for the C
    "malloc / free") so she does not have to manipulate pointers or to directly
    access memory.
    
    $\rightarrow$ Olena prevents the user from making mistakes;

\item Image data/values can be shared between several variables and the memory
    used for image data is handled by the library.
    
    $\rightarrow$ Memory management is automatic.
\end{itemize}



\section{Interface}

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

I::pvset & domain & - & X - &  \\ \hline
const Value\& & operator() & const point\& p & X & Used for reading. \\ \hline
Value\& & operator() & const point\& p & - & Used for writing. \\ \hline
const P\& & at & unsigned x,
         unsigned y & X & Used for reading. \\ \hline
P\& & at & unsigned x,
         unsigned y & - & Used for writing. \\ \hline
bool & has & const Point\& p & X & \\ \hline
bool & has\_data & - & X & Returns true if the domain is defined. \\ \hline
site\_id & id & - & X & Return the Id of the underlying shared data. \\ \hline
I::vset & destination & - & X & Value set of all the possible site values in this
Image. \\ \hline
site\_set & bbox & - & - & Returns the bounding box of the domain. \\ \hline
site\_set & bbox\_large & - & - & Returns the bouding box of the domain and the
extended domain. \\ \hline

\end{tabular}

\clearpage
\newpage
\chapter{Window and Neighborhood}




\clearpage
\newpage
\chapter{Sites, psites and dpoints}

\section{Need for site}

As we have seen before, an image is defined on a grid. It has associated
data and a site set which defines the domain of the image on that grid.
Usually, we need to access a value by its coordinates. With default images it
can be done easily, at no cost.

Example with an image2d:

\begin{lstlisting}[frame=single]
    c  0 1 2 3
   r
      +-+-+-+-+
   0  | |x| | |
      +-+-+-+-+
   1  | | | | |
      +-+-+-+-+
\end{lstlisting}

The site x is the point (0, 1).  The image values are stored in a
multi-dimensional array. The point coordinates can be used directly. The site
(0, 1) \textbf{is} the point (0, 1) and the data is stored at row 0 and column
1.

Here we have:

  I::site == I::psite == point2d

where, roughly, point2d = \{ row, column \}.

\section{Need for psite}

Sometimes, accessing a value in constant-time complexity, O(1), is not
possible with a site object.

Let's have a small example. Define a function returning a value for a given
point:
\clearpage
\begin{lstlisting}[frame=single]
  unsigned my_values(const point2d& p)
  {
    if (p.row() == 0)
      return 8;
    return 9;
  }
\end{lstlisting}
So, for each point having (0, x) as coordinate, this function will return 8,
otherwise it will be 9.

Then, define a p\_array with few point2d:

\begin{lstlisting}[frame=single]
  p_array<point2d> arr;
  arr.append(point2d(3, 6));
  arr.append(point2d(3, 7));
  arr.append(point2d(3, 8));
  arr.append(point2d(4, 8));
  arr.append(point2d(4, 9));
\end{lstlisting}

Now, create a point-wise image from this function and this p\_array:
\begin{lstlisting}[frame=single]
  mln_VAR(ima, my_values | arr);
\end{lstlisting}

Ima is actually that image:
\begin{lstlisting}[frame=single]
    c  6 7 8 9
   r
      +-+-+-+
   3  | |x| |
      +-+-+-+-+
   4      | | |
          +-+-+
\end{lstlisting}

However, in memory, since it is based on a p\_array, sites are stored in a
vector.

The site x is the point (3, 7) which corresponds to the cell 1 in the p\_array.

\begin{lstlisting}[frame=single]
arr[] = 0 1 2 3 4
       +-+-+-+-+-+
       | |x| | | |
       +-+-+-+-+-+
\end{lstlisting}

Obviously, we cannot check in constant time whether the site x, point2d here,
is part of that image or not: knowing the point coordinates is not enough.
That's why we need a different mechanism in order to access this information:
the psites.

Here we have:

  I::site == point2d  but  I::psite == pseudo\_site$<$point2d$>$

where, roughly, pseudo\_site$<$point2d$>$ = \{ i\_in\_p\_array, p\_array\_ptr
\}.

Psites contains all the needed information to access the values in
constant-time.

\section{From psite to site}

In the last example there was an image of type I such as I::site != I::psite. 
In that case, an object of type I::psite is actually convertible towards an
object of type I::site.  Furthermore, a psite shall behave as if it was a
site.

Design note: it seems impossible to offer through the interface of
some psite what is expected from its corresponding site.  For instance, when a
site has a given feature, say a method "m", then this
method has to appear in the psite interface. However, thanks to
inheritance, we fetch an interface and an implementation that delegates
to the site.

For instance, in the last example, I::psite has a method ::row() because
I::site, point2d, provides such a method.

How it works: a psite inherits from internal::site\_impl$<$site$>$ which is
specialized for every site type; for instance, internal::site\_impl$<$point2d$>$
owns the method "coord row() const" which is defined as
"return exact(this)-$>$to\_site().row()"

\section{Need for dpoint}
//FIXME

\clearpage
\newpage
\chapter{Iterators}

Each container object in Olena like site sets or images have iterators.
The iteration mechanism for images is directly derived from the mechanism
for site sets.

There are usually three kinds:
\begin{itemize}
\item \textbf{fwd\_iter}, depends on the container,
\item \textbf{bkd\_iter}, iterates like forward but to the opposite way,
\item \textbf{iter}, usually the same as fwd\_iter. It is guaranteed to
iterate all over the elements.
\end{itemize}
Every iterable object have these three kinds of iterator. There are all
bidirectional containers.
Whatever the iterator used, the basic iterator has the only property of
browsing every site once.

The iterator type name depends on the data pointed by it: \\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Data type & Iterator Names \\ \hline
Site & fwd\_piter, bkd\_piter, piter \\ \hline
Value & fwd\_viter, bkd\_viter, viter \\ \hline
\end{tabular} \\

As you may have noticed, according to the data type, the word "iter" is prefixed
by the usual name variable used for that data type. Sites variables are usually
called 'p' so the proper iterator is "piter". (See the foreword)\\


An iterator has the following interface: \\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Return Type & Name & Arguments & Const & Comments \\ \hline

void & start & - & - & \\ \hline
void & next & - & - & \\ \hline
bool & is\_valid & - & - & Return false if created with the default
constructor and not associated to a proper container.\\ \hline
\end{tabular} \\


Example of different forward iterations:
\begin{itemize}
  \item box2d: from top to bottom then from left to right.
  \item p\_array$<$point2d$>$: from left to right.
\end{itemize}

A for\_all() macro is available to iterate over all the sites: \\

\begin{lstlisting}[frame=single]
  box2d b(3, 2);
  mln_piter(box2d) p(b);

  for_all(p)
    std::cout << p; //prints every site coordinates.
\end{lstlisting}

Note that when you declare an iterator, prefer using the "mln\_*iter" macros.
They resolve the iterator type automatically from the given container type
passed as parameter. These macros can be used with any container like images or
site sets.

Here follow an example with the implemantions of the most basic routines which use the for\_all
loop: fill and paste.

\begin{lstlisting}[frame=single]
template <typename I>
void fill(I& ima, mln_value(I) v)
{
  mln_piter(I) p(ima.domain());
  for_all(p)
    ima(p) = v;
}
\end{lstlisting}


\begin{lstlisting}[frame=single]
template <typename I, typename J>
void paste(const I& data, J& dest)
{
  mln_piter(I) p(data.domain());
  for_all(p)
    dest(p) = data(p);
}
\end{lstlisting}

\clearpage
\newpage
\chapter{Basic operations}
//FIXME : illustrer

\section{Basic routines}
\begin{tabular}{|l|p{8cm}|}
\hline
Routine name & Description \\ \hline
level::clone() & creates a deep copy of an object. Any shared data is
duplicated. \\ \hline

level::fill() & fill an object with a value. \\ \hline

level::paste() & paste object data to another object. \\ \hline

labeling::blobs() & find and label the different components of an image. \\
\hline
\end{tabular} \\

\section{Fill}
First, create an image:
\begin{lstlisting}[frame=single]
  image2d<char> imga(0, 0, 20, 20);
\end{lstlisting}

Memory has been allocated so data can be stored but site values
have not been initialized yet.  So we fill img with the value 'a':
\begin{lstlisting}[frame=single]
  level::fill(imga.rw(), 'a');
\end{lstlisting}

The "fill" algorithm is located in the sub-namespace "level" since this
algorithm deals with the "level" of site values.

Note that the term "level" refers to the fact that an image can be considered as
a landscape where the elevation at a particular location/site is given by
the corresponding site value.

The full name of this routine is "oln::level::fill".  To access to a particular
algorithm, the proper file shall be included. The file names of algorithms
strictly map their C++ name; so oln::level::fill is defined in the file
"oln/level/fill.hh".

\subsection*{Note}
Most algorithms in Olena are constructed following the classical scheme: "output
algo(input)", where the input image is only read. However some few algorithms
take an input image in order to modify it.  To enforce this particular feature,
the user shall explicitly state that the image is provided so that its data is
modified "read/write". The algorithm call shall be "level::fill(ima.rw(),
val)". When forgetting the "rw()" call it does not compile.


\section{Paste}
We then define below a second image to play with.  As you can see this image has
data for the sites (5, 5) to (14, 14) (so it has 100 sites).  

\begin{lstlisting}[frame=single]
  image1d<char> imgb(5, 5, 14, 14);

  // We initialize the image values.
  level::fill(imgb.rw(), 'b');

  // Last we now paste the contents of img3b in img3a...
  level::paste(imgb, imga.rw()));

  // ...and print the result.
  debug::println(imga);
\end{lstlisting}

Before pasting, the couple of images looked like:

//FIXME : ajouter des zolies zimages.

so after pasting we get:

//FIXME : ajouter des zolies zimages again.

\subsection*{Note}
With this simple example we can see that images defined on different domains (or
set of sites) can interoperate.  The set of sites of an image is defined and
can be accessed and printed. The following code:

\begin{lstlisting}[frame=single]
  std::cout << "imga.domain() = " << imga.domain()
            << std::endl;
  std::cout << "imgb.domain() = " << imgb.domain()
            << std::endl;
\end{lstlisting}

Gives:
\begin{lstlisting}[frame=single]
  imga.domain() = { (0,0) .. (19,19) }
  imgb.domain() = { (5,5) .. (14,14) }
\end{lstlisting}

The notion of site sets plays an important role in Olena. Many tests are
performed at run-time to ensure that the program is correct.

For instance, the algorithm level::paste tests that the set of sites of imgb
(whose values are to be pasted) is a subset of the destination image.


\section{Blobs}
//FIXME: write it!

\newpage
\section{Working with parts of an image}

Sometime it may be interesting to work only on some parts of the image or to
extract only a sub set of that image. Olena enables that thoughout out the
operator '$|$'.

Three kinds of that operator exist:\\

\begin{tabular}{|l|l|l|l|p{4cm}|}
\hline
Prototype & Comments \\ \hline

Image $|$ Sub Domain & Create a new image.\\ \hline
Image $|$ Function\_p2b & Do not create a new image but create a morpher.\\
\hline
Function\_p2v $|$ Sub Domain & Do not create a new image but create a morpher.\\
\hline
\end{tabular} \\

A Sub Domain can be a site set, an image or any value returned by this
operator.
For a given site, Function\_p2v returns a Value and Function\_p2b returns a
boolean. These functions. are actually a sort of predicate. A common
function\_p2v is pw::value(Image). It returns the
point to value function used in the given image. C functions can also be used as
predicate by passing the function pointer.

You can easily get a function\_p2b by comparing the value returned 
by a function\_p2v to another Value.
The following sample codes illustrate this feature.

In order to use C functions as predicate, they must have one of the following
prototype if you work on 2D images:
\begin{lstlisting}[frame=single]
//function_p2b
bool my_function_p2b(mln::point2d p);

//function_p2v
//V is the value type used in the image.
V my_function_p2v(mln::point2d p);
\end{lstlisting}
Of course, you just need to change the point type if you use another image
type. For instance, you would use point3d with 3D images.
The returned value type V for function\_p2v depends on the image value type.
With image2d$<$int$>$, V would be int.

In this section, all along the examples, the image "ima" will refer to the
following declaration:
\begin{lstlisting}[frame=single]
  bool vals[6][5] = {
    {0, 1, 1, 0, 0},
    {0, 1, 1, 0, 0},
    {0, 0, 0, 0, 0},
    {1, 1, 0, 1, 0},
    {1, 0, 1, 1, 1},
    {1, 0, 0, 0, 0}
  };
  image2d<bool> ima = make::image2d(vals);
\end{lstlisting}

A simple example is to fill only a part of an image with a specific value:
\begin{lstlisting}[frame=single]
p_array2d<bool> arr;

// We add two points in the array.
arr.append(point2d(0, 1));
arr.append(point2d(4, 0));

// We restrict the image to the sites
// contained in arr and fill these ones
// with 0.
// We must call "rw()" here.
fill((ima | arr).rw(), 0);


mln_VAR(ima2, ima | arr);
// We do not need to call "rw()" here.
fill(ima2, 0);
\end{lstlisting}

The two next examples extract a specific component from an image and fill a new
image with red only in the extracted component's domain.
\begin{lstlisting}[frame=single]
  using namespace mln;
  using value::int_u8;
  using value::rgb8;

  // Find and label the different components.
  int_u8 nlabels;
  image2d<int_u8> lab = labeling::blobs(ima, c4(), nlabels);

  // Store a boolean image. True if the site is part of
  // component 2, false otherwise.
  mln_VAR(lab_2b, lab | (pw::value(lab) == 2));

  // Get the sub site set containing only the sites
  // part of component 2.
  mln_VAR(lab_2, lab_2b.domain(true));

  // Fill the sites of component 2 with red.
  fill(lab_2, color::red);
\end{lstlisting}

The previous example can be written more quickly:
\begin{lstlisting}[frame=single]
  using namespace mln;
  using value::int_u8;
  using value::rgb8;

  // Find and label the different components.
  int_u8 nlabels;
  image2d<int_u8> lab = labeling::blobs(ima, c4(), nlabels);

  // Fill the sites of component 2 with red.
  fill(lab.domain(2).rw(), color::red);
\end{lstlisting}

Here is an example using a C function:
\begin{lstlisting}[frame=single]
bool row_oddity(mln::point2d p)
{
  return p.row() % 2;
}

void my_function()
{
  ...
  //Prints only sites which are on odd lines.
  debug::println(ima | row_oddity};
  ...
}
\end{lstlisting}
%
%
\medskip
%
%
\subsection*{Important note}
When writing:

\begin{lstlisting}[frame=single]
  ima | sub_D
\end{lstlisting}

sub\_D must be included in ima.domain().

Let's have an image, \textit{imab}, like this:
\begin{lstlisting}[frame=single]
0 1 0
1 1 1
\end{lstlisting}

Extract a sub image from \textit{imab} with sites having their value set to 1.
\begin{lstlisting}[frame=single]
mln_VAR(imab1, imab | (pw::value(imab) == 1u));
\end{lstlisting}

Then, \textit{imab1} looks like:
\begin{lstlisting}[frame=single]
  1 
1 1 1
\end{lstlisting}

Now, if we want to extract a sub image it may fail, depending on the site set
used:
\begin{lstlisting}[frame=single]
box2d b1(1,0, 1, 2);
mln_VAR(imac, imab1 | b1);

// Print:
// 1 1 1
debug::prinln(imac);

box2d b2(0,0, 1, 1);
// Will fail at runtime.
// ima.domain().has((0,0)) is false.
mln_VAR(imad, imab1 | b2);
debug::prinln(imad);
\end{lstlisting}


If you do not want this constraint, you may want to use an alternative
operator:

\begin{lstlisting}[frame=single]
  ima / sub_D
\end{lstlisting}

In that case there is no restriction on the domain at all and the following example will work.
\begin{lstlisting}[frame=single]
box2d b2(0,0, 1, 1);

mln_VAR(imad, imab1 / b2);

// Print
//   1
// 1 1
debug::prinln(imad);
\end{lstlisting}
With this operator, an intersection is applied on the image domain and the
site set.

\newpage
\clearpage
\chapter{Graphes and images}

//FIXME: REWRITE

\section{Description}
Olena enables the possibility of using graphes with images.
Graphes can help you to handle directly parts of an image and represent their
relationship.
Specific data can be associated to each vertex and/or edges.

//FIXME: Add more explanations?

\section{Example}

First, create a graph which looks like the following:

\begin{lstlisting}[frame=single]
      0 1 2 3 4
   .-----------
 0 |  0       2
 1 |    \   / |
 2 |      1   |
 3 |       \  |
 4 |        3-4
\end{lstlisting}

To do so, we need to create a site set containing the sites we are going to use
as vertices:

\begin{lstlisting}
std::vector<point2d> sites;

// Site associated to...
sites.push_back(point2d(0,0)); // ... vertex 0.
sites.push_back(point2d(2,2)); // ... vertex 1.
sites.push_back(point2d(0,4)); // ... vertex 2.
sites.push_back(point2d(4,3)); // ... vertex 3.
sites.push_back(point2d(4,4)); // ... vertex 4.
\end{lstlisting}

Then populate the graph with vertices:
\begin{lstlisting}
util::graph<point2d> g;

for (unsigned i = 0; i < points.size(); ++i)
  g.add_vertex (points[i]);
\end{lstlisting}

Finally, populate the graph with edges:
\begin{lstlisting}
g.add_edge(0, 1); // Associated to edge 0.
g.add_edge(1, 2); // Associated to edge 1.
g.add_edge(1, 3); // Associated to edge 2.
g.add_edge(3, 4); // Associated to edge 3.
g.add_edge(4, 2); // Associated to edge 4.
\end{lstlisting}

Now, a graph structure is created but contains only site relationship
information. We may like to map data to it. Vertices and edges are mapped to
indexes. Indexes start from 0 and respect the insertion order.
Therefore, the idea is to provide a function which returns the associated data
according to the index given as parameter. Combining this function and the
graph, which is actually a sort of site set, we get an image. Since this is an
image, you can use it with algorithms and for\_all loops.

\begin{lstlisting}[frame=single]

Value my_data_fun(vertex_index_t index)
{
  if (index == 0)
    return value1;
  else if (index > 1 && < 4)
    return value2;
  return value3;
}

Value my_data_fun(edge_index_t index)
{
  if (index == 0)
    return value1;
  else if (index > 1 && < 4)
    return value2;
  return value3;
}

void my_fun()
{
  ...
  // Constructs an image which associates
  // data and edges. A site is actually an edge.
  mln_VAR(graph_edge_ima, my_data_fun | g.edges());

  //Prints each edge.
  mln_piter p(graph_edge_ima);
  for_all(p)
    std::cout << p << std::endl;

  // Constructs an image which associates
  // data and vertices. A site is actually a vertex.
  mln_VAR(graph_vertices_ima, my_data_fun2 | g.vertices());

  //Prints each vertex
  mln_piter p(graph_vertices_ima);
  for_all(p)
    std::Cout << p << std::endl;
  ...
}
\end{lstlisting}

Note that like any image in Olena, graph images share their data. Therefore,
while constructing a graph image from a graph and a function, the graph is not
copied and this is NOT a costly operation.

Like other images, graph images also have an overloaded operator() to access the
data associated to a vertex or an edge.
\begin{lstlisting}
  //Prints each edge's associated value.
  mln_piter p(graph_edge_ima);
  for_all(p)
    std::cout << graph_edge_ima(p) << std::endl;

  //Prints each vertex's associated value.
  mln_piter p(graph_vertex_ima);
  for_all(p)
    std::cout << graph_vertex_ima(p) << std::endl;
\end{lstlisting}

Of course, creating a graph image is not necessary and you can work directly
with the graph and container/function mapping indexes and data.

\begin{lstlisting}
// Iterator on vertices.
mln_Viter V(g);

// Prints each vertex and its associated value.
for_all(V)
{
  std::cout << V << " : " << my_data_fun(V) << std::endl;
}
\end{lstlisting}

Graphes have iterators like any other site sets and also provide
specific iterators in order to iterate over graphes in a more intuitive way.

\begin{lstlisting}
// Iterator on vertices.
mln_Viter V(g);

// Iterator on V's edges.
mln_Eiter n(g, V);

// Prints the graph
// List all edges for each vertex.
for_all(V)
{
  std::cout << V << " : ";
  for_all(n)
    std::cout << n << " ";
  std::cout << std::endl;
}

// Iterator on edges.
mln_Eiter E(g);

// Iterator on vertices adjacent to E.
mln_Viter n(g, E);

// Prints the graph
// List all adjacent vertices for each edge.
for_all(E)
{
  std::cout << E << " : ";
  for_all(n)
    std::cout << n << " ";
  std::cout << std::endl;
}
\end{lstlisting}

//FIXME talk about p\_vertices and p\_edges.

\end{document}

Ecriture de fonctions
=====================

# Fichiers

## Fonctions unaires et binaires
* *mln/fun/unary.hh*
* *mln/fun/binary.hh*

Définitions des meta-fonctions unaires et binaires

* *mln/fun/spe/binary.hh*
* *mln/fun/spe/unary.hh*

Modèles des fonctions unaires et binaires, instantiés par les meta-fonctions

## Fonctions paramétrées
* *mln/fun/param.hh*

Définitions concernant les fonctions paramétrées.

* *mln/fun/unary\_param.hh*
* *mln/fun/binary\_param.hh*

Raccourcis d'écritures pour les fonctions paramétrées

## Composition
* *mln/fun/compose.hh*

Fonction permettant de composer deux autres fonctions.

* *mln/fun/composition.hh*

Modèle du résultat de la composition de deux fonctions

## Traits
* *mln/trait/fun.hh*

Accès à diverses propriétés de la fonction.

mln\_trait\_fun\_is\_assignable, mln\_trait\_fun\_is\_parametrable: de type metal::bool\_

mln\_trait\_fun\_lvalue, mln\_trait\_fun\_param, mln\_trait\_fun\_storage: typedef si la fonction répond à cette propriété, void sinon


# Pure

L'ajout d'une nouvelle fonction s'effectue en deux étapes:
- la création d'un «flag», en général une structure vide héritant d'un modèle de meta-fonction.

        struct succ : mln::fun::unary<succ> {};

- la définition de la fonction sur un ou plusieurs types d'argument. Détaillée ci-après.

## Unaire

        #include <mln/fun/unary.hh>

Création du «flag» (on suppose que l'on se trouve dans le namespace mln::fun) :

        struct succ : unary<succ> {};

Définition sur les entiers, dans le namespace mln::trait::next :

        namespace mln
        {
          namespace trait
          {
            namespace next
            {
              template <typename T>
              struct set_unary_<mln::fun::succ, Integer, T>
              {
                typedef set_unary_ ret;
                
                typedef T argument;
                typedef T result;
                
                static result read(const argument& a)
                {
                  return a + 1;
                }
              };
            }
          }
        }

Ou, pour uniquement travailler sur les entiers non signés:

        namespace mln
        {
          namespace trait
          {
            namespace next
            {
              template <typename T>
              struct set_precise_unary_<mln::fun::succ, unsigned int>
              {
                typedef set_precise_unary_ ret;
                
                typedef unsigned int argument;
                typedef unsigned int result;
                
                static result read(const argument& a)
                {
                  return a + 1;
                }
              };
            }
          }
        }

Définitions attendues:

- typedef **ret**: la classe résultat. On peut ainsi renvoyer vers une autre classe, c'est alors dans celle-ci que devront se trouver les autres définitions.

- typedef **argument**: type de l'argument (unique) que prend la fonction.

- typedef **result**: type du résultat de la fonction

- méthode **read**: méthode donnant le résultat de l'application de la fonction.
        
        Elle doit répondre au prototype suivant:
                static result read(const argument&);

Le modèle mln::fun::unary prend deux paramètres:
        template \<typename F, typename E = F\>

Le premier est le drapeau, le second est le type exact (dans l'utilisation courante, les deux sont égaux).


## Binaire

        #include <mln/fun/binary.hh>

Création du «flag» (on suppose que l'on se trouve dans le namespace mln::fun) :

        struct plus : binary<plus> {};

Définition sur les scalaires, dans le namespace mln::trait::next :

        namespace mln
        {
          namespace trait
          {
            namespace next
            {
              template <typename T1, typename T2>
              struct set_binary_<mln::fun::plus, Scalar, T1, Scalar, T2>
              {
                typedef set_binary_ ret;
                
                typedef T1 argument1;
                typedef T2 argument2;
                typedef mln_sum(T1, T2) result;
                
                static result read(const argument1& a1, const argument2& a2)
                {
                  return a1 + a2;
                }
              };
            }
          }
        }

Ou, pour uniquement travailler entre entier non signé et flottant:

        namespace mln
        {
          namespace trait
          {
            namespace next
            {
              template <typename T>
              struct set_precise_binary_<mln::fun::plus, unsigned int, float>
              {
                typedef set_precise_binary_ ret;
                
                typedef unsigned int argument1;
                typedef float argument2;
                typedef float result;
                
                static result read(const argument1& a, const argument2& b)
                {
                  return a + b;
                }
              };
            }
          }
        }

Définitions attendues:

- typedef **ret**: la classe résultat. On peut ainsi renvoyer vers une autre classe, c'est alors dans celle-ci que devront se trouver les autres définitions.

- typedef **argument1**: type du premier argument que prend la fonction.

- typedef **argument2**: type du second argument que prend la fonction.

- typedef **result**: type du résultat de la fonction

- méthode **read**: méthode donnant le résultat de l'application de la fonction.
        
        Elle doit répondre au prototype suivant:
                static result read(const argument1&, const argument2&);

# Unaire affectable

Une fonction unaire peut parfois être affectable. Cela autorise des écritures telles que:
        cos(x) = 1;
        red(col) = 255;

Le terme "affectable" inclue la notion d'inversibilité de la fonction.
Pour supporter ce comportement, il faut ajouter aux définitions d'une fonction unaire pure les éléments suivants:

- typedef argument& **lvalue**: une fonction n'est considérée comme affectable que si ce typedef existe. Il donne de plus le type de l'argument de la fonction dans la notation "f(x) = y".

- méthode **write**: méthode dont le premier argument est accessible en lecture/écriture et dont le second argument donne le résultat attendu de la méthode read après l'application de write (cad, write(x, 1) => read(x) == 1).

        Elle doit répondre au prototype suivant:
                static void write(lvalue, const result&);

# Paramétrable

La définition des paramètres s'effectue en spécialisant le modèle mln::fun::parameter<Flag>.

        struct cos_ax;
        
        template <>
        struct parameter<cos_ax>
        {
          typedef int param;
        };
        
        struct cos_ax : unary<cos_ax>
        {
          cos_ax(int a) : unary<cos_ax>(a) {};
        };

Le modèle devant être spécialisé avant la définition de la meta-fonction, l'écriture peut sembler lourde. Un raccourcis est présenté dans les sections *unary_param* et *binary_param*. Il est nécessaire d'écrire le constructeur!

## Unaire

La présence d'un paramètre ajoute un argument aux méthodes read et write: la valeur donnée au paramètre est transmise en premier argument à read et, si applicable, à write.

Les prototypes deviennent:
        static result read(const param&, const argument&);
        static void write(const param&, lvalue, const result&);

### Exemple, implémentation de cos_ax

        template <typename S>
        struct set_unary_<mln::fun::cos_ax, Scalar, S>
        {
          typedef set_unary_ ret;
          
          typedef S argument;
          typedef S& lvalue;
          typedef double result;
          
          static result read(const int& a, const argument& x)
          {
            return math::cos(x) * a;
          }
          
          static void write(const int& a, lvalue l, const result& r)
          {
            l = math::acos(r) / a;
          }
        };

### unary_param

L'écriture passant par un modèle extérieur pouvant paraître lourde, le modèle unary_param permet de simplifier celle-ci.
        unary_param<Flag,Param,Storage,E>

E est le type exact, par défaut identique à Flag. Storage est expliqué dans la section éponyme.

Param est le type désiré pour le paramètre, similaire à parameter<T>::param.
Ainsi, cos_ax peut se déclarer de manière plus conçise:

        struct cos_ax : unary_param<cos_ax,int>
        {
          cos_ax(int a) : unary_param<cos_ax,int>(a) {};
        };

## Binaire

De même pour les fonctions binaires, la présence d'un paramètre ajoute un argument à la méthode read: la valeur donnée au paramètre est transmise en premier argument à read.

Le prototype devient:
        static result read(const param&, const argument1&, const argument2&);

### Exemple, interpolation linéaire

        struct lin_interp;
        
        template <>
        struct parameter<lin_interp>
        {
          typedef float param;
        };
        
        struct lin_interp : binary<lin_interp>
        {
          lin_interp(float a) : binary<lin_interp>(a) {};
        };
        
        template <typename S1, typename S2>
        struct set_binary_<mln::fun::lin_interp, Scalar, S1, Scalar, S2>
        {
          typedef set_binary_ ret;
          
          typedef S1 argument1;
          typedef S2 argument2;
          typedef double result;
          
          static result read(const float& a, const argument1& f1, const argument2& f2)
          {
            return a * f1 + (1.0f - a) * f2;
          }
        };

### binary_param

L'écriture passant par un modèle extérieur pouvant paraître lourde, le modèle binary_param permet de simplifier celle-ci.
        binary_param<Flag,Param,Storage,E>

E est le type exact, par défaut identique à Flag. Storage est expliqué dans la section éponyme.

Param est le type désiré pour le paramètre, similaire à parameter<T>::param.
Ainsi, lin_interp peut se déclarer de manière plus conçise:

        struct lin_interp : binary_param<lin_interp,float>
        {
          lin_interp(float a) : binary_param<lin_interp,float>(a) {};
        };

## «Storage»

Lors de la spécialisation de mln::fun::parameter, on peut définir le type "storage". Cela permet d'utiliser un type différent pour le stockage du paramètre, et éventuellement d'effectuer un calcul.
La présence de "storage" impose celle d'une méthode "compute":
        static double compute(const param&);

### Exemple

Dans le namespace mln::fun:

        struct log_n;
        
        template <>
        struct parameter<log_n>
        {
          typedef int param;
          typedef double storage;

          static double compute(const param& base)
          {
            return std::log(base);
          }
        };
        
        struct log_n : unary<log_n>
        {
          log_n(int n) : unary<log_n>(n) {};
        };

Dans le namespace mln::trait::next:

        template <typename S>
        struct set_unary_<mln::fun::log_n, Scalar, S>
        {
          typedef set_unary_ ret;
          
          typedef S argument;
          typedef S& lvalue;
          typedef double result;
          
          static result read(const double& log_base, const argument& x)
          {
            return std::log(x) / log_base;
          }
          
          static void write(const double& log_base, lvalue l, const result& r)
          {
            l = std::exp(r * log_base);
          }
        };

### ... avec unary_param

Dans le namespace mln::fun:
        
        struct log_n : unary_param<log_n, int, double>
        {
          log_n(int n) : unary<log_n>(n) {};

          static double compute_param(const int& n)
          {
            return std::log(base);
          }
        };

Dans le namespace mln::trait::next:

        template <typename S>
        struct set_unary_<mln::fun::log_n, Scalar, S>
        {
          typedef set_unary_ ret;
          
          typedef S argument;
          typedef S& lvalue;
          typedef double result;
          
          static result read(const double& log_base, const argument& x)
          {
            return std::log(x) / log_base;
          }
          
          static void write(const double& log_base, lvalue l, const result& r)
          {
            l = std::exp(r * log_base);
          }
        };

# Composition

La composition de fonctions opère entre une meta-fonction A unaire et une fonction B, éventuellement meta, unaire ou binaire. Le résultat est une fonction de l'arité de B, ou meta-fonction si B en est une.

Le type de la composée "F . G" est:
        mln::fun::internal::composition<Category_F, F, Category_G, G>

La manière la plus simple de composer est d'appliquer la seconde fonction à la première:
        cos(cos) est l'équivalent de "cos . cos"

Il existe également une fonction compose:

        mln::fun::compose compose;
        compose(cos,cos) en est un autre équivalent

# «thru»
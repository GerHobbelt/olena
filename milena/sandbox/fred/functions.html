<h1>Ecriture de fonctions</h1>

<h1>Fichiers</h1>

<h2>Fonctions unaires et binaires</h2>

<ul>
<li><em>mln/fun/unary.hh</em></li>
<li><em>mln/fun/binary.hh</em></li>
</ul>

<p>Définitions des meta-fonctions unaires et binaires</p>

<ul>
<li><em>mln/fun/spe/binary.hh</em></li>
<li><em>mln/fun/spe/unary.hh</em></li>
</ul>

<p>Modèles des fonctions unaires et binaires, instantiés par les meta-fonctions</p>

<h2>Fonctions paramétrées</h2>

<ul>
<li><em>mln/fun/param.hh</em></li>
</ul>

<p>Définitions concernant les fonctions paramétrées.</p>

<ul>
<li><em>mln/fun/unary_param.hh</em></li>
<li><em>mln/fun/binary_param.hh</em></li>
</ul>

<p>Raccourcis d'écritures pour les fonctions paramétrées</p>

<h2>Composition</h2>

<ul>
<li><em>mln/fun/compose.hh</em></li>
</ul>

<p>Fonction permettant de composer deux autres fonctions.</p>

<ul>
<li><em>mln/fun/composition.hh</em></li>
</ul>

<p>Modèle du résultat de la composition de deux fonctions</p>

<h2>Traits</h2>

<ul>
<li><em>mln/trait/fun.hh</em></li>
</ul>

<p>Accès à diverses propriétés de la fonction.</p>

<p>mln_trait_fun_is_assignable, mln_trait_fun_is_parametrable: de type metal::bool_</p>

<p>mln_trait_fun_lvalue, mln_trait_fun_param, mln_trait_fun_storage: typedef si la fonction répond à cette propriété, void sinon</p>

<h1>Pure</h1>

<p>L'ajout d'une nouvelle fonction s'effectue en deux étapes:
- la création d'un «flag», en général une structure vide héritant d'un modèle de meta-fonction.</p>

<pre><code>    struct succ : mln::fun::unary&lt;succ&gt; {};
</code></pre>

<ul>
<li>la définition de la fonction sur un ou plusieurs types d'argument. Détaillée ci-après.</li>
</ul>

<h2>Unaire</h2>

<pre><code>    #include &lt;mln/fun/unary.hh&gt;
</code></pre>

<p>Création du «flag» (on suppose que l'on se trouve dans le namespace mln::fun) :</p>

<pre><code>    struct succ : unary&lt;succ&gt; {};
</code></pre>

<p>Définition sur les entiers, dans le namespace mln::trait::next :</p>

<pre><code>    namespace mln
    {
      namespace trait
      {
        namespace next
        {
          template &lt;typename T&gt;
          struct set_unary_&lt;mln::fun::succ, Integer, T&gt;
          {
            typedef set_unary_ ret;

            typedef T argument;
            typedef T result;

            static result read(const argument&amp; a)
            {
              return a + 1;
            }
          };
        }
      }
    }
</code></pre>

<p>Ou, pour uniquement travailler sur les entiers non signés:</p>

<pre><code>    namespace mln
    {
      namespace trait
      {
        namespace next
        {
          template &lt;typename T&gt;
          struct set_precise_unary_&lt;mln::fun::succ, unsigned int&gt;
          {
            typedef set_precise_unary_ ret;

            typedef unsigned int argument;
            typedef unsigned int result;

            static result read(const argument&amp; a)
            {
              return a + 1;
            }
          };
        }
      }
    }
</code></pre>

<p>Définitions attendues:</p>

<ul>
<li><p>typedef <strong>ret</strong>: la classe résultat. On peut ainsi renvoyer vers une autre classe, c'est alors dans celle-ci que devront se trouver les autres définitions.</p></li>
<li><p>typedef <strong>argument</strong>: type de l'argument (unique) que prend la fonction.</p></li>
<li><p>typedef <strong>result</strong>: type du résultat de la fonction</p></li>
<li><p>méthode <strong>read</strong>: méthode donnant le résultat de l'application de la fonction.</p>

<pre><code>Elle doit répondre au prototype suivant:
        static result read(const argument&amp;);
</code></pre></li>
</ul>

<p>Le modèle mln::fun::unary prend deux paramètres:
        template \<typename F, typename E = F\></p>

<p>Le premier est le drapeau, le second est le type exact (dans l'utilisation courante, les deux sont égaux).</p>

<h2>Binaire</h2>

<pre><code>    #include &lt;mln/fun/binary.hh&gt;
</code></pre>

<p>Création du «flag» (on suppose que l'on se trouve dans le namespace mln::fun) :</p>

<pre><code>    struct plus : binary&lt;plus&gt; {};
</code></pre>

<p>Définition sur les scalaires, dans le namespace mln::trait::next :</p>

<pre><code>    namespace mln
    {
      namespace trait
      {
        namespace next
        {
          template &lt;typename T1, typename T2&gt;
          struct set_binary_&lt;mln::fun::plus, Scalar, T1, Scalar, T2&gt;
          {
            typedef set_binary_ ret;

            typedef T1 argument1;
            typedef T2 argument2;
            typedef mln_sum(T1, T2) result;

            static result read(const argument1&amp; a1, const argument2&amp; a2)
            {
              return a1 + a2;
            }
          };
        }
      }
    }
</code></pre>

<p>Ou, pour uniquement travailler entre entier non signé et flottant:</p>

<pre><code>    namespace mln
    {
      namespace trait
      {
        namespace next
        {
          template &lt;typename T&gt;
          struct set_precise_binary_&lt;mln::fun::plus, unsigned int, float&gt;
          {
            typedef set_precise_binary_ ret;

            typedef unsigned int argument1;
            typedef float argument2;
            typedef float result;

            static result read(const argument1&amp; a, const argument2&amp; b)
            {
              return a + b;
            }
          };
        }
      }
    }
</code></pre>

<p>Définitions attendues:</p>

<ul>
<li><p>typedef <strong>ret</strong>: la classe résultat. On peut ainsi renvoyer vers une autre classe, c'est alors dans celle-ci que devront se trouver les autres définitions.</p></li>
<li><p>typedef <strong>argument1</strong>: type du premier argument que prend la fonction.</p></li>
<li><p>typedef <strong>argument2</strong>: type du second argument que prend la fonction.</p></li>
<li><p>typedef <strong>result</strong>: type du résultat de la fonction</p></li>
<li><p>méthode <strong>read</strong>: méthode donnant le résultat de l'application de la fonction.</p>

<pre><code>Elle doit répondre au prototype suivant:
        static result read(const argument1&amp;, const argument2&amp;);
</code></pre></li>
</ul>

<h1>Unaire affectable</h1>

<p>Une fonction unaire peut parfois être affectable. Cela autorise des écritures telles que:
        cos(x) = 1;
        red(col) = 255;</p>

<p>Le terme "affectable" inclue la notion d'inversibilité de la fonction.
Pour supporter ce comportement, il faut ajouter aux définitions d'une fonction unaire pure les éléments suivants:</p>

<ul>
<li><p>typedef argument&amp; <strong>lvalue</strong>: une fonction n'est considérée comme affectable que si ce typedef existe. Il donne de plus le type de l'argument de la fonction dans la notation "f(x) = y".</p></li>
<li><p>méthode <strong>write</strong>: méthode dont le premier argument est accessible en lecture/écriture et dont le second argument donne le résultat attendu de la méthode read après l'application de write (cad, write(x, 1) => read(x) == 1).</p>

<pre><code>Elle doit répondre au prototype suivant:
        static void write(lvalue, const result&amp;);
</code></pre></li>
</ul>

<h1>Paramétrable</h1>

<p>La définition des paramètres s'effectue en spécialisant le modèle mln::fun::parameter<Flag>.</p>

<pre><code>    struct cos_ax;

    template &lt;&gt;
    struct parameter&lt;cos_ax&gt;
    {
      typedef int param;
    };

    struct cos_ax : unary&lt;cos_ax&gt;
    {
      cos_ax(int a) : unary&lt;cos_ax&gt;(a) {};
    };
</code></pre>

<p>Le modèle devant être spécialisé avant la définition de la meta-fonction, l'écriture peut sembler lourde. Un raccourcis est présenté dans les sections <em>unary_param</em> et <em>binary_param</em>. Il est nécessaire d'écrire le constructeur!</p>

<h2>Unaire</h2>

<p>La présence d'un paramètre ajoute un argument aux méthodes read et write: la valeur donnée au paramètre est transmise en premier argument à read et, si applicable, à write.</p>

<p>Les prototypes deviennent:
        static result read(const param&amp;, const argument&amp;);
        static void write(const param&amp;, lvalue, const result&amp;);</p>

<h3>Exemple, implémentation de cos_ax</h3>

<pre><code>    template &lt;typename S&gt;
    struct set_unary_&lt;mln::fun::cos_ax, Scalar, S&gt;
    {
      typedef set_unary_ ret;

      typedef S argument;
      typedef S&amp; lvalue;
      typedef double result;

      static result read(const int&amp; a, const argument&amp; x)
      {
        return math::cos(x) * a;
      }

      static void write(const int&amp; a, lvalue l, const result&amp; r)
      {
        l = math::acos(r) / a;
      }
    };
</code></pre>

<h3>unary_param</h3>

<p>L'écriture passant par un modèle extérieur pouvant paraître lourde, le modèle unary<em>param permet de simplifier celle-ci.
        unary</em>param<Flag,Param,Storage,E></p>

<p>E est le type exact, par défaut identique à Flag. Storage est expliqué dans la section éponyme.</p>

<p>Param est le type désiré pour le paramètre, similaire à parameter<T>::param.
Ainsi, cos_ax peut se déclarer de manière plus conçise:</p>

<pre><code>    struct cos_ax : unary_param&lt;cos_ax,int&gt;
    {
      cos_ax(int a) : unary_param&lt;cos_ax,int&gt;(a) {};
    };
</code></pre>

<h2>Binaire</h2>

<p>De même pour les fonctions binaires, la présence d'un paramètre ajoute un argument à la méthode read: la valeur donnée au paramètre est transmise en premier argument à read.</p>

<p>Le prototype devient:
        static result read(const param&amp;, const argument1&amp;, const argument2&amp;);</p>

<h3>Exemple, interpolation linéaire</h3>

<pre><code>    struct lin_interp;

    template &lt;&gt;
    struct parameter&lt;lin_interp&gt;
    {
      typedef float param;
    };

    struct lin_interp : binary&lt;lin_interp&gt;
    {
      lin_interp(float a) : binary&lt;lin_interp&gt;(a) {};
    };

    template &lt;typename S1, typename S2&gt;
    struct set_binary_&lt;mln::fun::lin_interp, Scalar, S1, Scalar, S2&gt;
    {
      typedef set_binary_ ret;

      typedef S1 argument1;
      typedef S2 argument2;
      typedef double result;

      static result read(const float&amp; a, const argument1&amp; f1, const argument2&amp; f2)
      {
        return a * f1 + (1.0f - a) * f2;
      }
    };
</code></pre>

<h3>binary_param</h3>

<p>L'écriture passant par un modèle extérieur pouvant paraître lourde, le modèle binary<em>param permet de simplifier celle-ci.
        binary</em>param<Flag,Param,Storage,E></p>

<p>E est le type exact, par défaut identique à Flag. Storage est expliqué dans la section éponyme.</p>

<p>Param est le type désiré pour le paramètre, similaire à parameter<T>::param.
Ainsi, lin_interp peut se déclarer de manière plus conçise:</p>

<pre><code>    struct lin_interp : binary_param&lt;lin_interp,float&gt;
    {
      lin_interp(float a) : binary_param&lt;lin_interp,float&gt;(a) {};
    };
</code></pre>

<h2>«Storage»</h2>

<p>Lors de la spécialisation de mln::fun::parameter, on peut définir le type "storage". Cela permet d'utiliser un type différent pour le stockage du paramètre, et éventuellement d'effectuer un calcul.
La présence de "storage" impose celle d'une méthode "compute":
        static double compute(const param&amp;);</p>

<h3>Exemple</h3>

<p>Dans le namespace mln::fun:</p>

<pre><code>    struct log_n;

    template &lt;&gt;
    struct parameter&lt;log_n&gt;
    {
      typedef int param;
      typedef double storage;

      static double compute(const param&amp; base)
      {
        return std::log(base);
      }
    };

    struct log_n : unary&lt;log_n&gt;
    {
      log_n(int n) : unary&lt;log_n&gt;(n) {};
    };
</code></pre>

<p>Dans le namespace mln::trait::next:</p>

<pre><code>    template &lt;typename S&gt;
    struct set_unary_&lt;mln::fun::log_n, Scalar, S&gt;
    {
      typedef set_unary_ ret;

      typedef S argument;
      typedef S&amp; lvalue;
      typedef double result;

      static result read(const double&amp; log_base, const argument&amp; x)
      {
        return std::log(x) / log_base;
      }

      static void write(const double&amp; log_base, lvalue l, const result&amp; r)
      {
        l = std::exp(r * log_base);
      }
    };
</code></pre>

<h3>... avec unary_param</h3>

<p>Dans le namespace mln::fun:</p>

<pre><code>    struct log_n : unary_param&lt;log_n, int, double&gt;
    {
      log_n(int n) : unary&lt;log_n&gt;(n) {};

      static double compute_param(const int&amp; n)
      {
        return std::log(base);
      }
    };
</code></pre>

<p>Dans le namespace mln::trait::next:</p>

<pre><code>    template &lt;typename S&gt;
    struct set_unary_&lt;mln::fun::log_n, Scalar, S&gt;
    {
      typedef set_unary_ ret;

      typedef S argument;
      typedef S&amp; lvalue;
      typedef double result;

      static result read(const double&amp; log_base, const argument&amp; x)
      {
        return std::log(x) / log_base;
      }

      static void write(const double&amp; log_base, lvalue l, const result&amp; r)
      {
        l = std::exp(r * log_base);
      }
    };
</code></pre>

<h1>Composition</h1>

<p>La composition de fonctions opère entre une meta-fonction A unaire et une fonction B, éventuellement meta, unaire ou binaire. Le résultat est une fonction de l'arité de B, ou meta-fonction si B en est une.</p>

<p>Le type de la composée "F . G" est:
        mln::fun::internal::composition<Category_F, F, Category_G, G></p>

<p>La manière la plus simple de composer est d'appliquer la seconde fonction à la première:
        cos(cos) est l'équivalent de "cos . cos"</p>

<p>Il existe également une fonction compose:</p>

<pre><code>    mln::fun::compose compose;
    compose(cos,cos) en est un autre équivalent
</code></pre>

<h1>«thru»</h1>

-*-  outline -*-

* Introduction


* What is a property?

** Two types of properties

*** Declarative mode: (find an example).

Here, the properties must be define by the image type programmer. They cannot
be deduce from the image associated type. So we can't find the properties by
introspecting the image type.


 declaration        definition     ..... I check
 -------          ----------
|       |       /            \
| Props | ----> | Image Type |
|       |       \ __________ /
 -------



*** Automatic mode: (find an example).

Here, we get the image properties from the image associated type
(site, pset...).


   ----------
 /            \
 |            |
 | Image Type |
 |     and    |   automatic ----->       Props
 |  associated|
 |     type   |
 \ __________ /



** Semantic

Properties are a way to classify the images depends or their type.

*** Static Checking

  Some operators are only define in special cases. Properties provide a way to
check that the operator input type respect the operator requirement.

*** Specialization of an Algorithm
  (ex: dilatation/erosion).
TODO: detail the example.

*** Implementation inheritance

Milena image types are property driven.
It is possible to get a special behavior (not describe in the Image Concept)
depends on the property define in the property associated for the image
type. So, it is possible to recover some piece of interface depending on the
image type properties.
For instance an Image2d has the bi-dimensional, and random value access.
 properties. Hence, Image2d automatically provides a row/column access:
V at(Point2d<T>::coord x, Point2d<T>::coord y).


*** Difference between a property and its values

*** Hierarchies of property (scalar/integer)

** Implementation of properties in Milena


* List of the image properties:

** global Properties:

  category: primary,
            { domain_morpher, value_morpher,  identity_morpher } < morpher

  border: none,
          { stored, computed } <some

  neighb: none,
          some

  data: stored,
        linear < stored
        raw < linear,
        computed

  io:  read,
       write,
       read_only < read,
       write_only < write,
       read_write < both read'n write

  speed: slow,
         fast,
         fastest


** Properties related to I::value
    kind: color,
          gray,
	  label,
	  logic < label,
          binary < logic,
          data

    quant: low,
           high

    value: scalar,
           vectorial,
           structed,
           pointer


** Properties related to I::pset
      access: random,
              browsing

      space:  one_d,
              two_d,
              three_d

      size:   huge,
              regular

      support: irregular,
               regular
               aligned < regular


* Values Properties:
      nature: scalar,
              { integer, floating } < scalar,
              vectorial,
	      matric,
	      symbolic,
	      strutured,
	      unknow

      kind: color,
            grey,
            label,
            logic < label,
            binary < logic,
	    data

      quant: low,
             high



* Image types and their associated properties

** Primitive Image

Primitive image are image which are not based on another image type.

A primitive image type property can be either declared or automatically get
back with the help of associated types.


FIXME: find a good notation...

** Image nD

Image on regular grid where grid nodes are points.
To gain efficiency, Images nD have a virtual borders.
All these image are templated by T, the image value type.


*** Common Associated type//properties between imageND

**** Associated types:

value = T

**** Properties:

--> global properties

category = primary
border = stored
neighb: none
data = raw
io = read_write
speed = fastest

--> properties related to values

// Depend on T FIXME, where the property are defined??
kind =
quant =
value =

--> properties related to the pset

access = random
size = regular // this a global property
support = aligned

*** Image1d<T>

**** Associated types:

site  = point1d
psite = point1d == point_<tick,int>
pset = box1d

**** Properties:

space = one_d


**** Specific interface:
  FIXME....

*** Image2d<T>

**** Associated types:

site  = point2d
psite = point2d == point_<square,int>
pset = box2d

**** Properties:

space = two_d


**** Specific interface:
  FIXME....

*** Image3d<T>

**** Associated types:

value = T

**** Properties:

space = three_d

**** Specific interface:
  FIXME....



** Image based on function

The images based on function are templated by F and P, where
F is p2v function type and P a psite

Question: Is there any restriction on F and S ??
-> S must be include in the definition set of F

*** pw::image<F, S>

**** Associated types:

value = F::result

site  = S::site
psite = S::pset
pset = S

**** Properties:

--> global properties

category = primary
border = none
neighb: none
data = computed // computed => read_only!
io = read_only
speed = fast

--> properties related to values

kind =??
quant =??
value = fixme

--> properties related to the pset

access = browsing // Why the access property is set to browsing?
space = fixme_
size = regular
support = fixme

FIXME: see how to fix all the fixme in the pw::image properties.
How to deal with the lvalue??

Is there any lvalue for image with computed data?
lvalue just for image with stored//read_only data?

**** Specific interface:
  FIXME....

** Run based Encoded image

All the run based encoded images have their definition domains encoded by runs.
These images types are not morpher types since these do not lie on another
image type.A run is a "continuous" (note this is wrong, cf graph index) set of
sites.It is define by a site start, and a length. All the run based encoded
image are templated by P, T where P is a site type and T a value type.

Note:
type one shot (const)!!!
Do we store the the null value in the rle encoding.
(Do we compress all the images values, or only the image objects...)
Is there any restriction on P and T?

How the properties are setted and to which values?


*** Criteria needed by images to be encoded in runs

Can we compress all the image types or only the piece wise image type
(cf the on_the_same_line in the encode algorithm).

Currently, *encode function just work with image based on a **Point** set.
cf:
for (unsigned n = 0; same_line && n < dim - 1; ++n)
    same_line = (p1[n] == p2[n]);

Problem generalization:
  A p_run take a Site as a parameter.
  a p_run must be able to be casted into the Site (actually, const Site).
  The only information that we have in the p_run is a len (integer).
  So we must be able to refind all the site in the run from the site start,
and a addition with an integer.

  How do we name this property?




*** RLE Image

A RLE image can be defined as the following:
{(p, v)} where p is a run of P and v is a value of type T.


**** Associated types:

value = T

site  = P
psite = runs_psite<P>
pset = p_runs_<P>

**** Properties:

--> global properties

category = primary
border = none
neighb: none
data = linear
io = read_only
speed = slow

--> properties related to values

// Depend on T FIXME, where the property are defined??
kind =
quant =
value =

--> properties related to the pset

access = browsing
space = depend on P //FIXME the property setted in the milena code is wrong.
size = regular  // Should we say compressed?
support = depend on P // The property setted in the milena code is wrong


*** Compact RLE

*** Sparse Image

A RLE image can be defined as the following:
{(p, [v])} where p is a run of P and v is a value of type T, and [v] is an
array of size p.length().


**** Associated types:

value = T

site  = P
psite = runs_psite<P>
pset = p_runs_<P>

**** Properties:

Same properties than the RLE Image type.


*** Value encoded image


** Graph Image

FIXME: See with roland

**** Connectivity based on a graph.


** Morpher (Derived Image)

Mopher are Image types which transform an Image type into a new type. So, they
rest upon another images types. Most of the mopher properties are
transformation of the input image type properties.

A morpher image type property can be declared, automatically get back with
the help of the associated type or be a transformation of a property of the
input image type.

*** Identity morpher

*** Domain morpher

*** Value morpher

*** Image_if

???




Note:
The different grid (retrieve from point_ class):
 - tick,
 - square,
 - hexa,
 - cube

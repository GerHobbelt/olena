-*-  outline -*-

* Introduction


* What is a property?

** Two types of properties

*** Declarative mode: (find an example).

Here, the properties must be define by the image type programmer. They cannot
be deduce from the image associated type. So we can't find the properties by
introspecting the image type.


 declaration        definition     ..... I check
 -------          ----------
|       |       /            \
| Props | ----> | Image Type |
|       |       \ __________ /
 -------



*** Automatic mode: (find an example).

Here, we get the image properties from the image associated type
(site, pset...).


   ----------
 /            \
 |            |
 | Image Type |
 |     and    |   automatic ----->       Props
 |  associated|
 |     type   |
 \ __________ /



** Semantic

Properties are a way to classify the images depends or their type.

*** Static Checking

  Some operators are only defined in special cases. Properties provide a way to
check that the operator's input types respect the operator requirements.

*** Specialization of an Algorithm
  (ex: dilatation/erosion).
TODO: detail the example.

*** Implementation inheritance

Milena image types are property driven.
It is possible to get a special behavior (not describe in the Image Concept)
depends on the property define in the property associated for the image
type. So, it is possible to recover some piece of interface depending on the
image type properties.

//FIXME Bad example
For instance an Image2d has the bi-dimensional, and random value access.
 properties. Hence, Image2d automatically provides a row/column access:
V at(Point2d<T>::coord x, Point2d<T>::coord y).


*** Difference between a property and its values

*** Hierarchies of property (scalar/integer)

** Implementation of properties in Milena


* List of the image properties:

** global Properties:

  category: primary,
            { domain_morpher, value_morpher,  identity_morpher } < morpher

  border: none,
          { stored, computed } <some

  neighb: none,
          some

  data: stored,
        linear < stored
        raw < linear,
        computed

  io:  read,
       write,
       read_only < read,
       write_only < write,
       read_write < both read'n write

  speed: slow,
         fast,
         fastest


** Properties related to I::value
    kind: color,
          gray,
	  label,
	  logic < label,
          binary < logic,
          data

    quant: low,
           high

    value: scalar,
           vectorial,
           structed,
           pointer


** Properties related to I::pset
      access: random,
              browsing

      space:  one_d,
              two_d,
              three_d

      size:   huge,
              regular

      support: irregular,
               regular
               aligned < regular


* Values Properties:
      nature: scalar,
              { integer, floating } < scalar,
              vectorial,
	      matric,
	      symbolic,
	      strutured,
	      unknow

      kind: color,
            grey,
            label,
            logic < label,
            binary < logic,
	    data

      quant: low,
             high



* Image types and their associated properties

** Primitive Image

Primitive image are images which are not based on another image type.

A primitive image type property can be either declared or automatically get
back with the help of associated types.


FIXME: find a good notation...

** Image nD

Image on regular grid where grid nodes are points.
To gain efficiency, Images nD have a virtual borders.
All these image are templated by T, the image value type.


*** Common Associated type//properties between imageND

**** Associated types:

value = T

**** Properties:

--> global properties

category = primary
border = stored
neighb: none
data = raw
io = read_write
speed = fastest

--> properties related to values

// Depend on T FIXME, where the property are defined??
kind =
quant =
value =

--> properties related to the pset

access = random
size = regular // this a global property
support = aligned

*** Image1d<T>

**** Associated types:

site  = point1d
psite = point1d == point_<tick,int>
pset = box1d

**** Properties:

space = one_d


**** Specific interface:
  FIXME....

*** Image2d<T>

**** Associated types:

site  = point2d
psite = point2d == point_<square,int>
pset = box2d

**** Properties:

space = two_d


**** Specific interface:
  FIXME....

*** Image3d<T>

**** Associated types:

value = T

**** Properties:

space = three_d

**** Specific interface:
  FIXME....



** Image based on function

The images based on function are templated by F and P, where
F is p2v function type and P a psite

Question: Is there any restriction on F and S ??
-> S must be include in the definition set of F

*** pw::image<F, S>

**** Associated types:

value = F::result

site  = S::site
psite = S::pset
pset = S

**** Properties:

--> global properties

category = primary
border = none
neighb: none
data = computed // computed => read_only!
io = read_only
speed = fast


--> properties related to the pset

access = browsing // Why the access property is set to browsing?
space = fixme_
size = regular
support = fixme

FIXME: see how to fix all the fixme in the pw::image properties.
How to deal with the lvalue??

Is there any lvalue for image with computed data?
lvalue just for image with stored//read_only data?

**** Specific interface:
  FIXME....

** Run based Encoded image

All the run based encoded images have their definition domains encoded by runs.
These images types are not morpher types since these do not lie on another
image type.
All the run based encoded images are templated by P, T where P is a site type
and T a value type.

Note:
type one shot (const)!!!
Do we store the the null value in the rle encoding.
( <=> Do we compress all the images values, or only the image objects...)
Is there any restriction on P and T?

*** Notation used:
  (a, b) represents a pair composed by two elements..
  {a, b, c...} represents a list of elements.

*** What is a run?

**** Definition

// FIXME choose a better word than continuous.
A run is a "continuous" succession of sites.
All the sites encoded in a same run have the same value in the corresponding
image.

It is defined by a site "start", and a length.

ex:
        start    length of
        site     the run
      ((1, 2),      6  )


  see the image:

    1 - 1 - 2
    |   |   |
    2 - 2 - 2
    |   |   |
    3 - 3 - 3

Its corresponding runs are:
{
  ( (0, 0), 2 ),
  ( (0, 2), 1 ),
  ( (1, 0), 3 ),
  ( (2, 0), 3 ),
}

Note: there is two different runs for the value 2:
  ( (0, 2), 1 ),
  ( (1, 0), 3 ).

Indeed the points (0, 2) and (1, 0) are not "continuous".



**** Difference between data stored in a linear way and runs.

A run doesn't represent only a continuous memory zone.
A run has also a localization aspect.
From a run, we can get all the points which compose it.

For instance, look at the following run:


  i_run:  0 1 2 3
         +-+-+-+-+
 (0, 4)  |1|1|1|1|  <=> ( (0, 4), 4 )
         +-+-+-+-+

The points composing this run are:
(0, 4), (0, 5), (0, 6), (0, 7)

This property is really important to guarantee the interoperability
between the different image types.

**** PieceWise property

The run is templated by a site type.
But does we have any restriction on the type of site?

The answer seems to be yes, the run must have a localization aspect.
To allow this localization, we must be able to convert a p_run into its
corresponding sites.
So we must be able to convert a site and i_run index to another site.

ex:

(0, 4) + 3 give us the site (0, 7).

It has two consequences:
- a site must be convertible into a vector of coordinates
- We must a know to which coordinate we add the i_run index to compute another
  site. We will choose the coordinate which vary the most.

This lead us to the PieceWise property:
  The site can be represented by a vector of coordinates, and this vector has a
coordinate which vary more than the other. (And we have an access to these
coordinates).



**** Why a run has to be a "continuous" succession of sites?

We can imagine that a run is a succession of noncontinuous sites.
For instance look at the following image:

  1 - 1 - 2
  |   |   |
  2 - 2 - 2  This image is based on a grid which has its deltaX equal to 10
  |   |   |  and its deltaY equal to 30.
  1 - 1 - 1

So the points localized on the grid are:

 (0, 0)  - (10, 0)  - (20, 0)
   |         |         |
 (0, 30) - (10, 30) - (20, 30)
   |         |         |
 (0, 60) - (10, 60) - (20, 60)


The corresponding encoded image with "noncontinuous" runs will be:

  { ((a,1), 2), ((b,2), 1), ((c,2), 3), ((c,3), 3) }

with a = (0, 0), b = (20, 0), c = (0, 30), d = (0, 60).

Another representation of the encoded image is:

  i_run:  0 1 2
         +-+-+
 (0, 0)  |1|1|
         +-+-+
 (20, 0) |2|
         +-+-+-+
 (0, 30) |2|2|2|
         +-+-+-+
 (0, 60) |1|1|1|
         +-+-+-+

Here, we loose the localization aspect of the psite.
Indeed a psite (p_run) is represented by a site (pstart), and an integer
(i_run). With these information, we can access to all the value in the encoded
image. However we can not convert a psite (p_run) into a site (point2d).
For instance:

      psite                 ->   site
 (pstart: (0, 60) i_run: 2) ->  (2, 60)

However, the point (2, 60) doesn't belong to the image pset.
The expected result here is (20, 60).
This problem is an outcome of the holes present in the original image grid.
So, this is an outcome of the "noncontinuous" aspect of the run.

This approach implies one direct drawback: we loose the interoperability
between the encoded image type and other image  types (We cannot convert a
p_run into the corresponding site).
So, a run has to be a continuous succession set of points.

Another solution is to store the deltaX of the grid inside the psite.
This way, we have enough information to convert a p_run into a point2d.
But encoding a graph image  will not work either, even with the second
solution. Indeed, nothing assure us that the site on a graph are "continuous".

Do we need a property for that?.

Another problem with "noncontinuous" run is the index access ambiguity.
If the image provide an index access, the point represented by the indexes i,j
is not necessarily the same point represented by the indexes i,j in the
encoded image.


**** Which kind of image can be encoded? / Conclusion

We need two condition to encode an image type into a run encoded types.
First the image psite type must be piece wise.
Furthermore, the image must be based on a (regular) grid without any "holes".

All image{1, 2, 3}d types can be encoded.
Image based on a lut can be encoded too.
Function image with a regular grid can be encoded.
And morphers types based on a regular grid can be encoded too.


*** RLE Image

A RLE image can be defined as the following:
{(p, v)} where p is a run of P and v is a value of type T.


**** Associated types:

value = T
site  = P
psite = runs_psite<P>
pset = p_runs_<P>

**** Properties:

--> global properties

category = primary
border = none
neighb: none
data = linear
io = read_only
speed = slow

--> properties related to values

// Depend on T FIXME, where the property are defined??
kind =
quant =
value =

--> properties related to the pset

access = browsing
space = depend on P //FIXME the property setted in the milena code is wrong.
size = regular  // Should we say compressed?
support = depend on P // The property setted in the milena code is wrong



**** Example:

Consider the following image on regular grid.

  1 - 1 - 2
  |   |   |
  2 - 2 - 2
  |   |   |
  1 - 1 - 1

The encoded image is:

{
        psite    value
    ( ((0, 0), 2), 1 ),
    ( ((0, 2), 1), 2 ),
    ( ((1, 0), 3), 2 ),
    ( ((2, 0), 3), 1 ),
}


*** Compact RLE

FIXME

*** Sparse Image

A RLE image can be defined as the following:
{(p, [v])} where p is a run of P and v is a value of type T, and [v] is an
array of size p.length().


**** Associated types:

value = T
site  = P
psite = runs_psite<P>
pset = p_runs_<P>

**** Properties:

Same properties than the RLE Image type.

**** Examples:

Consider the following images:

The empty case denote there is no data at this coordinate.

  1 - 2 - 3 -   -   -
  |   |   |   |   |   |
    -   -   - 2 - 2 - 2
  |   |   |   |   |   |
    -   -   - 4 - 5 - 8
  |   |   |   |   |   |
    -   -   -   -   -


Its sparse encoding is:

{    psite         values
   ( ((0, 0), 3), {1, 2, 3}),
   ( ((1, 3), 3), {2, 2, 2}),
   ( ((2, 3), 3), {4, 5, 6}),
}



*** Value encoded image

**** Definition:

A value image is an image which associate a value to its corresponding psite.
So, we can easily get all the psites/site which have their (in O(1) complexity)

{
  (v, {runs})
}

**** Associate types:

value = T
site  = P
psite = runs_psite<P>
pset = p_runs_<P>

**** Properties:
  Same as rle image.

**** Example:


See
  1 - 1 - 1 -   -   -
  |   |   |   |   |   |
    -   -   - 2 - 2 - 2
  |   |   |   |   |   |
    -   -   - 2 - 2 - 2
  |   |   |   |   |   |
  3 - 3 - 3 - 4 - 4 - 4

The corresponding encoded image is:


{
  (1, {((0, 0), 3)} ),

  (2, {((1, 3), 3),
       ((2, 3), 3)} ),

  (3, {((3, 0), 3)} ),

  (4, {((3, 3), 3)} )
}


*** Image based on Lut

**** Definition

An image based on a lut is primitive image type.
This kind of image use a look up table to retrieve a value
associated to an image site.

It can be defines as followed:

  ({values}, {lut_values})


FIXME: How do we deal with the dimensions of the images?



**** Associated type

site=P
psite=P
value=V
pset=pset<P>


**** Property:

--> global properties

category = primary
border = none
neighb: none
data = stored
io = read_write
speed = fast

--> properties related to values

kind =
quant =small
value = V

--> properties related to the pset

access = browsing // Why the access property is set to browsing?
space = pset<P>::space
size = regular
support = pset<P>::supper


**** Example:

Consider this image type:

{ data =
    +-----------+
    | 0 2 1 0 2 |
    | 0 0 3 2 1 |
    | 2 1 2 2 0 |
    +-----------+;
  lut =
    +---+---------------+
    | 0 | (255,  0,  0) |  red (r)
    | 1 | (127,127,127) |  medium grey (m)
    | 2 | (  0,  0,255) |  blue (b)
    | 3 | (127,127,127) |  medium grey (m) again
    +---+---------------+
}

This image is defined with a look-up table; its external
representation actually is:

    +-----------+
    | r b m r b |
    | r r m b m |
    | b m b b r |
    +-----------+


** Graph Image

FIXME: See with roland

**** Connectivity based on a graph.

** Morpher (Derived Image)

Mopher are Image types which transform an Image type into a new type. So, they
rest upon another images types. Most of the mopher properties are
transformation of the input image type properties.

A morpher image type property can be declared, automatically get back with
the help of the associated type or be a transformation of a property of the
input image type.

*** Identity morpher

  No change in the property.

FIXME: Is there any property define for these types?

**** decorated_image
  templated image: I (image), D (decorator).
Image that can have additional features.


**** plain
  Prevent an image from sharing data.

**** safe
  Make an image accessible at undefined location.


**** interpolated
  Make an image readable with float coordinates.

**** neigh::image
  Add a neighbohood to an image.

Changed properties:
category -> morpher
neighb -> some


*** Domain morpher

**** sub_image

Make image restricted to a given pset.

Changed Properties:
  category -> domain_morpher
  border -> none

**** hexa

 Make an hexagonal Mesh of the image.
(work only with 2D image).

Changed Properties:
  category -> domain_morpher
  grid -> regular

**** Image_if
 Parameter I, F
 Make an image which has its domain restricted to a function.

Changed Properties:
  category -> domain_morpher
  io -> read_only if I is cont, trait::image_<I>::io otherwise
  data -> if the data property of I is linear then stored (FIXME why?)
          else like I



**** Image_if_interval
 Image which domain is restricted by an interval

Changed Property:
  Same as image_if



**** translate
 Translate an Image with a delta point.
Changed Property:
   category -> domain_morpher_category.

*** Value morpher

**** cast_image
Make the user see the same image but with another data type.

Changed properties:
   io -> read_only

**** value::stack_image
 Represent a Stack of image.

Changed properties:
   category -> value_morpher
   value -> value::vectorial
   speed -> fast

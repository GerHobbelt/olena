I ARBORESCENCE
--------------

bench  ==> Comparaison d'algorithmes d'un point de vue temps d'exécution.
bug    ==> Bug rencontrés dans milena et archivés sous forme de programme.
build  ==> Répertoire d'exécution, non sauvé dans git.
demo   ==> Première version d'un algorithme pour voir son comportement.
doc    ==> Documentation tex ou code minimal pour de petits exemples.
exp    ==> Version avancée des algorithmes pour traitées les bases de données.
mln    ==> Partie mise en librairie milena des différents travaux.
tests  ==> Tests unitaires sur certains algorithmes.
tools  ==> Découpage de certains algorithmes pour mieux les tester séparément.
use    ==> Test de compilation, code minimal pour compiler un élément.

II COMPILATION
--------------

L'unité minimale de code choisie est le répertoire.
Donc aller dans le répertoire qui nous interesse,
par exemple, green/demo/annotating/hsv et lancé le make

#:~/git/olena/scribo/sandbox/green$cd demo/annotating/hsv
#:~/git/olena/scribo/sandbox/green/demo/annotating/hsv$ make -f Makefile.am

Cette opération créé dans build le répertoire de compilation
green/build/demo/annotating/hsv. Dans ce répertoire aura été copié un
Makefile et tous les fichiers qui ne sont pas des sources. Par
exemple, des fichiers de calibration comme gaussian.sh (pour vérifier
la mire du filtre de gaussienne) ou de la documentation à la sauvette
sous forme de fichiers textes jetés à la va vite dans le répertoire
pour ne pas perdre l'information recherchée. En l'occurence, ici, il
n'y a rien à copier. Rendons-nous dans le répertoire de compilation et lançons
le makefile.

#:~/git/olena/scribo/sandbox/green/demo/annotating/hsv$
cd ../../../build/demo/annotating/hsv

#:~/git/olena/scribo/sandbox/green/build/demo/annotating/hsv$ make clean all

L'exécutable est généré par le makefile, il porte le nom du
répertoire.  Si il y a besoin de mettre à jour le makefile, le faire
dans le répertoire des sources en éditant Makefile.am, puis en
régénérant le Makefile dans le répertoire d'exécution par la commande
make -f Makefile.am depuis le répertoire source.


III MAKEFILE
------------

Les makefiles utilisés sont tous les mêmes avec quelques variables
dont le contenu change dans leur partie en-tête.

Pour chaque répertoire, le makefile doit savoir si le chemin courant
est un répertoire de compilation ou un répertoire de source. Pour les
identifier, il a recours à un pattern qui malheureusemnt fait
intervenir le nom de la branche de développement (bench,demo,bug,exp ...).

SOURCE_PATTERN= green/demo
BUILD__PATTERN= green/build/demo

Si un makefile ne fonctionne pas, il faut vérifier ceci en premier
lieu. Ici, le makefile doit être situé dans la branche démo.

Autre élément à savoir, la compilation nécessite d'inclure la
librairie milena, ainsi que les développements propres en vu de leur
intégration futur dans milena, ceci est fait par un jeu d'INCLUDES1
et INCLUDES2.

INCLUDES1= -I$(HOME)/git/olena/scribo/sandbox/green
INCLUDES2= -I$(HOME)/git/olena/milena
INCLUDES=  $(INCLUDES1) $(INCLUDES2)

Suivant l'allure du compte où l'on exécute les makefiles, il faut
revoir le chemin pour trouver des deux répertoires.

Enfin, les options de compilations ne sont pas toujours les mêmes. Les
trois lignes possibles sont toutes présentes et seule celle qui est
utilisée n'est pas commentée. Typiquement, dans la branche de
développement démo où les perfomances ne sont pas le problème, on
compilera avec tout le matériel pour utiliser gdb et sans
optimisation. A l'inverse, dans la branche d'expérimentation, où le
code a déjà été testé, on cherche à aller vite car on exécute ce code
sur de nombreuses images. Dans cette optique, pas de débugage, pas de
traçage, optimisation conséquente.

CXXFLAGS= -ggdb -O0 -Wall -W -pedantic -ansi -pipe $(INCLUDES)
#CXXFLAGS= -DNDEBUG -O1 -Wall -W -pedantic -ansi -pipe $(INCLUDES)
#CXXFLAGS= -DNDEBUG -O3 -Wall -W -pedantic -ansi -pipe $(INCLUDES)

Une dernière dernière information, dans le cadre des développements
exp, et tools, on utilise la librairie boost soit pour la
virtualisation du filesystem, soit pour le formatage des fichiers text
(réalisation de colonnes, mettre des entiers sur un certain nombre de
caractères). Une ligne de chargement des librairies peut apparaitre donc.

LOADLIBES= -lboost_filesystem

On retrouvera les includes suivantes dans les sources:

#include <boost/format.hpp>
#include <boost/filesystem.hpp>


IV CHEMINS DES IMAGES
---------------------

Toutes les images ont toujours été locales sur mon ordinateur. La
politique a toujours été d'utiliser un fichier img_path pour coder les
chemins des images.  Les chemins étant plutôt long, j'ai toujours eu
tendance à faire en sorte qu'ils soient compilés en dur (sauf pour la
partie développement tools qui est vraiment voué à donner des
exécutables indépendants et génériques). Le fichier mln/img_path.hh
code la position de toutes les images dans mon arborescence. Il faudra
donc veiller à changer tous les chemins pour les adapter au compte
dans lequel on voudra reprendre le code. Dans le code, les références
aux positions des images sont faites via des macros.

Toutes les images sont située dans git/img. En règle générale, je ne
traite que des images au format .pgm, .pbm et .ppm. Il m'arrive
fréquemment de dumper des images au format .sh (gnuplot shell
image). Pour la branche tools, nous avons utilisé les dumps de milena
comme format de transfert d'un utilitaire à un autre. Les images sont
classées suivant leur provenance. Nous avons tout d'abord la base
OLENA (copie des images de tests milena), la base INIM (très peu
utilisée voire jamais), la base ICDAR (très utilisée, surtout dans
exp), la base AFP (très utilisée dans exp) et les bases ANNOTATING1 et
ANNOTATING2 (pas très utilisées ni l'une, ni l'autre).

La plus part du temps, sauver les résultats dans le répertoire
d'exécution courant est largement suffisant. Parfois, il est
nécessaire de sauvegarder de grosses quantités d'informations et de
les classer comme dans la branche de développement exp. C'est pour
cela, qu'un certain nombre de macros définissent des endroits pour
sauvegarder les résultats lors d'expérimentation de grande ampleur sur
toute la base ICDAR ou AFP.


V GNUPLOT SCRIPT SHELL IMAGE FORMAT
-----------------------------------

J'abrège le nom du format par gnuplot shell format. En fait, c'est un
format d'image particulier qui a besoin de gnuplot pour être lu. Il
est donc compatible avec aucun viewer si ce n'est gnuplot, mais a la
caractéristique d'afficher tous les points de manière visible. Par
ailleurs, comme il s'agit d'un script gnuplot il permet d'insérer très
facilement une fonction pour visualiser les données autrement (par
exemple, changer d'espace: HSL, HSV). Le fichier tire son nom de la
façon dont il fonctionne. C'est un script shell qui fait un appel à
gnuplot et lui passe le jeu de données directement à partir de ce même
fichier, pas besoin de faire appel à un autre fichier. Une fois
généré, le fichier doit être modifié pour avoir les permissions
d'exécution (chmod 755 gnuplot_shell_file.sh). Comme je trouve le format
extrêmement pratique, il se retrouve preque partout dans mes sources.


V MLN
-----

a) La sauvegarde des images au format gnuplot shell

* mln/io/plot/save_image_sh.hh: Librairie sauvegarde format gnuplot shell.

to do ...



b) Les histogrammes

Un des travaux demandés par théo est la réalisation d'une librairie
d'histogramme permettant de fournir un résultat sous forme d'image.
L'intérêt est ensuite de pouvoir filtrer directement ces histogrammes
par les algorithmes de milena, ou encore d'étudier les valeurs
caractéristiques par d'autres accumulateurs. Les codes réellement
utilisés sont histo1d et histo3d RGB. Tous les autres codes sont très
expérimentaux. Notemment, le code HSL demande de quantifier l'espace
de comptage puisqu'il est décrit sous la forme de triplets de float
(les autres sont inférés). Néanmoins, le code est à conserver car il
contient une séquence d'appels pour les routines permettant de
considérer la dimension de la teinte comme circulaire.

* mln/accu/stat/histo1d.hh: Accumulateur histogramme image1d.
* use/accu/stat/histo1d: Code minimal utilisant un histogramme 1d.

* mln/accu/stat/histo2d.hh: Accumulateur histogramme image2d.
* mln/value/rg.hh: Définition du type vectoriel 2d rouge/vert (RG).
* mln/fun/v2v/rgb_to_rg.hh: Transformation de l'espace RGB vers l'espace RG.
* use/accu/stat/histo2d: Code minimal utilisant un histogramme 2d.


* mln/accu/stat/histo3d_rgb.hh: Accumulateur histogramme image3d RGB.
* mln/accu/stat/histo3d_hsl.hh: Accumulateur histogramme image3d HSL.

* use/accu/stat/histo3_rgb: Code minimal utilisant un histogramme 3d RGB.
* use/accu/stat/histo3_hsl: Code minimal utilisant un histogramme 3d HSL.



* tests/accu/stat/histo1d




* tests/accu/stat/histo2d



* use/accu/stat/histo3d_rgb
* tests/accu/stat/histo3d_rgb

* use/accu/stat/histo3d_hsl
* tests/accu/stat/histo3d_hsl


c) La visualisation des histogrammes 3d

* demo/accu/stat/histo2d

* mln/display/dispay_histo.hh
* mln/displayproject_histo.hh

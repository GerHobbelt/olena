
%============================================================
\section{A Tour of Several Paradigms}

%........................................................................
\begin{frame}
  \frametitle{Intents}

  FIXME: context + get the best of both OOP and GP.

\end{frame}



%------------------------------------------------------------
\subsection{Classical OOP}


%........................................................................
\begin{frame}
  \frametitle{Classical Object-Oriented Programming}

  \begin{itemize}
    % 
  \item we design class hierarchies
    \begin{itemize}
    \item class inheritance translates the \textit{is-a} relationship
    \item a concrete class usually derives from an abstract class
    \end{itemize}
    \smallskip
    % 
  \item an abstract class
    \begin{itemize}
    \item maps an \textit{abstraction}
    \item describes an \textit{interface}
    \end{itemize}
    \smallskip
    % 
  \item a concrete class
    \begin{itemize}
    \item is a realization of its immediate abstraction
    \item implements its interface and those inherited
    \end{itemize}
    % 
  \end{itemize}

\end{frame}



%........................................................................
\begin{frame}
  \frametitle{Simple Class Hierarchy + Algorithm}

\begin{multicols}{2}
%
  \begin{center}
    \includegraphics[scale=.7]{simpleoo}
  \end{center}
%
\columnbreak
%
{\scriptsize
\begin{algorithm}{count}{it : Iterator}
  counter : \tunsigned \= 0 \\
  it.init() \\
  \begin{WHILE}{it.is\_valid()}
    \tab counter \= counter + 1 \\
    \tab it.next()
  \end{WHILE} \\
  \RETURN counter
\end{algorithm}
}
%
\end{multicols}

\end{frame}



%........................................................................
\begin{frame}[fragile]
  \frametitle{Translation into C++ OOP}


\begin{multicols}{2}
%
\begin{lstlisting}[escapechar=@]
class @\blueIterator@
{
public:
  virtual void init() = 0;
  virtual void next()  = 0;
  virtual bool is_valid() const = 0;
  virtual ~Iterator() {}
};

template <typename T>
class @\color{mediumblue}{array\_iterator}@ : public @\blueIterator@
{
public:
  virtual void init() { ... }
  virtual void next() { ... }
  virtual bool is_valid() const { ... }
  ...
};
\end{lstlisting}
%
\columnbreak
%
\begin{lstlisting}[escapechar=@]
unsigned count(@\blueIterator@& it)
{
  unsigned counter = 0;
  it.init();
  while (it.is_valid()) {
    counter = counter + 1;
    it.next();
  }
  return counter;
}
\end{lstlisting}
%
\end{multicols}

\end{frame}



%........................................................................
\begin{frame}
  \frametitle{Conclusion About C++ OOP}


\begin{block}{C++ OOP in a Nutshell}
  \begin{itemize}
  \item[\bplus] Abstract classes \\
    ~~~ {\tiny{$\leadsto$ ~ abstractions clearly appear in programs and allow for overloading of algorithms}}
  \item[\bplus] The OO Polymorphism \\
    ~~~ {\tiny{$\leadsto$ ~ method dispatch is a very convenient and straightforward tool}}
  \item[\bminus] Poor efficiency \\
    ~~~ {\tiny{$\leadsto$ ~ ``virtual'' methods are penalizing when involved in intensive computation}}
  \item[\bminus] No support for covariance and virtual types \\
    ~~~ {\tiny{$\leadsto$ ~ see later}}
  \end{itemize}
\end{block}

\end{frame}




%------------------------------------------------------------
\subsection{Classical Generic Programming (GP)}


%........................................................................
\begin{frame}[fragile]
  \frametitle{Documentation and Implementation}

\begin{multicols}{2}
%
  \begin{center}
    \includegraphics[scale=.7]{simplegp}
  \end{center}
%
\columnbreak
%
{\scriptsize
\begin{itemize}
\item in code:
  \begin{itemize}
  \item no actual abstract classes
  \item only implementation classes
  \end{itemize}
  \smallskip
\item limited OOP:
  \begin{itemize}
  \item abstractions only appear in documentation
  \item inheritance is just a factoring tool
  \end{itemize}
\end{itemize}
}
%
\end{multicols}

\end{frame}



%........................................................................
\begin{frame}[fragile]
  \frametitle{Translation into C++ Generic Programming}

\begin{multicols}{2}
%
\begin{lstlisting}[escapechar=@]
/* documentation:
 * 
 * Iterator
 * {
 *   void init();
 *   void next();
 *   bool is_valid() const;
 * };
 */

template <typename T>
class array_iterator
{
public:
  void init() { ... }
  void next() { ... }
  bool is_valid() const { ... }
  ...
};
\end{lstlisting}
%
\columnbreak
%
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
unsigned count(@\greenI@& it)
{
  unsigned counter = 0;
  it.init();
  while (it.is_valid()) {
    counter = counter + 1;
    it.next();
  }
  return counter;
}
\end{lstlisting}
%
\end{multicols}

\end{frame}



%........................................................................
\begin{frame}
  \frametitle{Conclusion About C++ GP}

\begin{block}{C++ GP in a Nutshell}
  \begin{itemize}
  \item[\bplus]  Efficiency \\
    ~~~ {\tiny{$\leadsto$ ~ algorithms do not pay the cost of abstractions}}
  \item[\bminus] Implicit abstractions \\
    ~~~ {\tiny{$\leadsto$ ~ abstractions are not mapped into code so program expressiveness is limited}}
  \item[\bminus] No support for constrained genericity \\
    ~~~ {\tiny{$\leadsto$ ~ being able to overload generic algorithms is not trivial}}
  \item[\bminus] Factoring code using inheritance is usually hard \\
    ~~~ {\tiny{$\leadsto$ ~ postponing definitions to sub-classes and
        overriding do not work well without the 'virtual'
        keyword}}
  \end{itemize}
\end{block}

\end{frame}




%------------------------------------------------------------
\subsection{Generic Programming Evolution with C++0x}



%........................................................................
\begin{frame}[fragile]
  \frametitle{Concepts and Implementation}

\begin{multicols}{2}
%
  \begin{center}
    \includegraphics[scale=.7]{simple0x}
  \end{center}
%
\columnbreak
%
{\scriptsize
\begin{itemize}
\item in code:
  \begin{itemize}
  \item concepts + implementation classes
  \item no need of setting explicit relations between them
    % concepts and classes
  \end{itemize}
  \smallskip
\item consequences:
  \begin{itemize}
  \item stronger type-checking than in GP
  \item great decoupling between concepts and classes
  \item inheritance remains a factoring tool
  \end{itemize}
\end{itemize}
}
%
\end{multicols}

\end{frame}



%........................................................................
\begin{frame}[fragile]
  \frametitle{Translation into C++0x}

\begin{multicols}{2}
%
\begin{lstlisting}[escapechar=@]
auto concept @\blueIterator@ <typename @\greenI@>
{
  void I::init();
  void I::next();
  bool I::is_valid() const;
};

template <typename T>
class array_iterator
{
public:
  void init() { ... }
  void next() { ... }
  bool is_valid() const { ... }
  ...
};
\end{lstlisting}
%
\columnbreak
%
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
where @\blueIterator@<@\greenI@>
unsigned count(@\greenI@& it)
{
  unsigned counter = 0;
  it.init();
  while (it.is_valid()) {
    counter = counter + 1;
    it.next();
  }
  return counter;
}
\end{lstlisting}
%
\end{multicols}

\end{frame}




%........................................................................
\begin{frame}
  \frametitle{Conclusion About C++0x}

\begin{block}{C++0x in a Nutshell}
  \begin{itemize}
  \item[\bplus] Efficiency, expressiveness, and type safety \\
    ~~~ {\tiny{$\leadsto$ ~ most drawbacks of OOP and GPP disappear!}}
  \item[\bminus] Not really OO \\
    ~~~ {\tiny{$\leadsto$ ~ like with GP we cannot take advantage of many designs related to ``classical'' inheritance}}
  \item[\bminus] Not yet part of the C++ standard \\
    ~~~ {\tiny{$\leadsto$ ~ so is there something to do now but waiting?}}
  \end{itemize}
\end{block}

\end{frame}




%------------------------------------------------------------
\subsection{Mixing OOP and GP}



%........................................................................
\begin{frame}
  \frametitle{Combining Inheritance and Genericity}

\begin{multicols}{2}
%
  \begin{center}
    \includegraphics[scale=.7]{simplescoop1}
  \end{center}
%
\columnbreak
%
\vspace*{.2\textheight}
\begin{itemize}
\item close to OOP
  \begin{itemize}
  \item we have class hierarchies
  \item but method lookup is solved at compile-time!
  \end{itemize}
\item close to GP
  \begin{itemize}
  \item algorithms are fast
  \item but their signatures are as strong as in C++0x!
  \end{itemize}
\end{itemize}
%
\end{multicols}

\end{frame}



%........................................................................
\begin{frame}[fragile]
  \frametitle{Translation into \scoop 1}

\begin{multicols}{2}
%
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
class @\blueIterator@ : public @\color{darkgray}{Any}@<I>
{
public:
  void init() { this->@\color{darkgray}{exact()}@.impl_init(); }
  void next() { /* likewise */ }
  bool is_valid() const  { /* likewise */ }
};



template <typename T>
class @\blueArrayIterator@ : public @\blueIterator@< array_iterator<T> >
{
public:
  void impl_init() { ... }
  void impl_next() { ... }
  bool impl_is_valid() const { ... }
  ...
};
\end{lstlisting}
%
\columnbreak
%
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
unsigned count(@\blueIterator@<@\greenI@>& it)
{
  unsigned counter = 0;
  it.init();
  while (it.is_valid()) {
    counter = counter + 1;
    it.next();
  }
  return counter;
}
\end{lstlisting}
%
\end{multicols}

\end{frame}




%........................................................................
\begin{frame}
  \frametitle{Conclusion About \scoop~1}

\begin{block}{\scoop~1 in a Nutshell}
  \begin{itemize}
  \item[\bplus] Efficiency, expressiveness, and type safety \\
    ~~~ {\tiny{$\leadsto$ ~ most drawbacks of OOP and GPP disappear!}}
  \item[\bplus] Really OO \\
    ~~~ {\tiny{$\leadsto$ ~ a mix between OOP and GP}}
  \item[\bminus] Not so trivial C++ \\
    ~~~ {\tiny{$\leadsto$ ~ yet not so difficult neither!}}
  \item[\bminus] Explicit inheritance \\
    ~~~ {\tiny{$\leadsto$ ~ just like in OOP...}}
  \end{itemize}
\end{block}

\end{frame}




%------------------------------------------------------------
\subsection{Recap + Comparison}



%........................................................................
\begin{frame}[fragile]
  \frametitle{Abstraction and Algorithm}

\hspace*{-3mm}
\begin{tabular}{|c|p{.45\textwidth}|p{.4\textwidth}|}
%
\hline
%
{\small OOP}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
class @\blueIterator@
{ ... };
\end{lstlisting}
\end{minipage}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
unsigned count(@\blueIterator@& it);
\end{lstlisting}
\end{minipage}
\\
%
\hline
%
{\small GP}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
/* documentation: Iterator
    ... */
\end{lstlisting}
\end{minipage}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
unsigned count(@\greenI@& it);
\end{lstlisting}
\end{minipage}
\\
%
\hline
%
{\small C++0x}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
auto concept @\blueIterator@ <typename @\greenI@>
{ ... };
\end{lstlisting}
\end{minipage}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
where @\blueIterator@<@\greenI@>
unsigned count(@\greenI@& it);
\end{lstlisting}
\end{minipage}
% template <@\blueIterator@ @\greenI@>
\\
%
\hline
%
{\small \scoop}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
class @\blueIterator@ : public @\color{darkgray}{Any}@<I>
{ ... }
\end{lstlisting}
\end{minipage}
&
\begin{minipage}{.9\textwidth}
\begin{lstlisting}[escapechar=@]
template <typename @\greenI@>
unsigned count(@\blueIterator@<@\greenI@>& it);
\end{lstlisting}
\end{minipage}
\\
%
\hline
%
\end{tabular}


\end{frame}



%........................................................................
\begin{frame}
  \frametitle{Paradigms At a Glance}

\newcommand{\badweak}{\color{red}{weak}}
\newcommand{\badexplicit}{\color{red}{explicit}}
\newcommand{\badno}{\color{red}{no}}
\newcommand{\badpoor}{\color{red}{poor}}

\newcommand{\yestrong}{\color{darkgreen}{strong}}
\newcommand{\yeimplicit}{\color{darkgreen}{implicit}}
\newcommand{\yeyes}{\color{darkgreen}{yes}}
\newcommand{\yegreat}{\color{darkgreen}{great}}

\newcommand{\ftypetotype}{{\scriptsize{$f: \mathit{type} \rightarrow \mathit{type}$}}}

\hspace*{-5mm}
\begin{tabular}{|c||c|c|c|c|c|}
\hline
            & OOP               & GP                    & C++0x               & \scoop            & \scoop 2            \\
\hline
\hline
2003 C++    & \yeyes            & \yeyes                & \badno               & \yeyes            & \yeyes             \\
inheritance & ok                & \badpoor              & \badpoor             & \yegreat          & \yegreat           \\
abstraction & {\bf class}       & \textsc{rtfm}         & {\bf concept}        & {\bf class}       & {\bf struct}       \\
relation    & \badexplicit      & \yeimplicit           & \yeimplicit          & \badexplicit      & quasi-\yeimplicit  \\
signature   & \yestrong         & \badweak              & \yestrong            & \yestrong         & \yestrong          \\
efficiency  & \badpoor          & \yegreat              & \yegreat             & \yegreat          & \yegreat           \\
\hline
\hline
\ftypetotype& \badno            & \badno                & \badno               & \badno            & \yeyes             \\
\hline
\end{tabular}

\end{frame}


%%% Local Variables:
%%% mode: latex
%%% eval: (ispell-change-dictionary "american")
%%% TeX-master: "slides"
%%% End:

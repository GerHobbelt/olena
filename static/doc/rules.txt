SCOOP 2 -- rules						-*- outline -*-


* Keywords

- Keywords added to the language (both SCOOL or C++):

  delegatee_type		(FIXME: or stc_delegatee_type?)
  abstract			(syntax: ``= 0'')
  final				(syntax: ``final vtype ...'')
  stc::not_found		(note: different from mlc::not_found)
  stc::not_delegated

  stc::not_delegated_abstract   (private type, used internally --
                                cannot be used by the programmer).

  stc::none			(FIXME: What about stc::top ?)

  deferred_type?		(FIXME: Which syntax?)


* Declaration/definition

** Class definition

- A class has almost the same meaning as in C++: an entity gathering
  data and operations.  C++ (as well as SCOOL) also allows classes to
  define types (via typedefs); this ability is part of SCOOP, and is
  extended to the notion of virtual types (see the relevant item).

  Ex.:

    class A < stc::none =
    {
      // A variable.
      var pi : float = 3.14;
      // A function.
      fun sqr : (a : int) -> int
        => a * a;
      // A (classical) type.
      type t = int
      // A virtual type.
      vtype vt = float;
    }

  In the present document, we will mainly deal with virtual type.

- A class must inherit from another class.  When a class has
  semantically no superclass, its superclass must be set to stc::none.
  A class having no supertype is invalid.

  Ex.:

    // Valid (assuming S is a valid class).
    class A < S =
    {
      // ...
    }

  Ex.:

    // Valid.
    class A < stc::none =
    {
      // ...
    }

  Ex.:

    // Invalid.
    class A =
    {
      // ...
    }

** Virtual type definition

- Each class can provide zero, one or more virtual type(s).

  // FIXME: Validity of the definition? What can the user put in RHS?
  // What about deferred type?

  Ex.:

    class A < stc::none =
    {
      vtype my_type = int;
    }


** Virtual type re-definition

- Unless declared final (see relevant item), a virtual type of a class
  can be redefined in its subclass(es).  The new value can be the same
  or different for the inital one.  The syntax is the same as the one
  for defining a virtual type.

  Ex.:

    class A < stc::none =
    {
      vtype my_type = int;
    }
    // Valid.
    class B < A =
    {
      vtype my_type = float;
    }
    // Valid.
    class C < A =
    {
      vtype my_type = int;
    }

FIXME: Restrictions on computed values? (-> deferred vtypes, etc.)

** Virtual type abstract declaration (i.e., deferred definition)

- The definition of a virtual type can be deferred, i.e. a virtual
  type can be just /declared/.  Such a virtual type is said to be
  abstract. A non-abstract virtual type is said to be concrete.

  A class containing at least an abstract virtual type
  (resp. containing no virtual type) is said abstract
  (resp. concrete).

  Ex.:

    class A < stc::none =
    {
      // my_type is abstract.
      vtype my_type = 0;
    }
    class B < A =
    {
      vtype my_type = int;
    }

- A concrete virtual type cannot be redefined as abstract.

  Ex.:

    class A < stc::none =
    {
      vtype my_type = int;
    }
    // Invalid.
    class B < A =
    {
      vtype my_type = 0;
    }


** Final virtual type

- A virtual type can be tagged as final.

  Ex.:

    class A < stc::none =
    {
      final vtype my_type = int;
    }

- A virtual type tagged as final in a class cannot be redefined in its
  subclasses, either tagged final or not, even if its value is
  unchanged.

  Ex.:

    class A < stc::none =
    {
      final vtype my_type = int;
    }
    // Invalid.
    class B < A =
    {
      vtype my_type = float;
    }
    // Invalid.
    class C < A =
    {
      vtype my_type = int;
    }
    // Invalid.
    class D < A =
    {
      final vtype my_type = int;
    }
    // Invalid.
    class E < A =
    {
      final vtype my_type = float;
    }

- A final type cannot be abstract.

  Ex.:

    // Invalid.
    class A < stc::none =
    {
      final vtype my_type = 0;
    }

FIXME: Is that all concerning abstract and final?


** Delegation

As stated before, any class has a super class in the SCOOP paradigm.
SCOOP also allows a class to have a /delegatee/, i.e., a type it can
use or depend on -- but without fulfilling the ``IS A'' relationship.

- There is at most one delegatee (having a delegatee is not
  mandatory).

- Delegation is introduced thanks to a special virtual type,
  delegatee_type (see below).

*** Delegatee type

- The virtual type `delegatee_type' is special: it is not looked up like
  the other virtual types (see the lookup section).

    class D < stc::none =
    {
    }
    class A < stc::none =
    {
      vtype delegatee_type = D;
    }
  
- A delagatee_type virtual type can be abstract in a class, and given
  a concrete definition in a subclass.  As for other virtual types,
  the fact that it is abstract renders the class abstract.

  Ex.:

    class D < stc::none =
    {
    }
    class A < stc::none =
    {
      // Deferred definition of delagatee_type.
      vtype delegatee_type = 0;
    }
    class B < A =
    {
      vtype delegatee_type = D;
    }
  
- If its no abstract, the value of a delegatee_type virtual type must
  be a (SCOOP) class name.

    class A < stc::none =
    {
      // Invalid.
      vtype delegatee_type = int;
    }

- The virtual type `delegatee_type' cannot be tagged as final.
  However, if its is actually defined (not just declared) in a class,
  the delegatee_type virtual type cannot be subsequently redefined in
  any of its subclasses, either with the same value or with another
  one.


  Ex.:

    class D1 < stc::none =
    {
    }
    class D2 < stc::none =
    {
    }
    class A < stc::none =
    {
      vtype delegatee_type = D1;
    }
    class B < A =
    {
      // Invalid.
      vtype delegatee_type = D1;
    }
    class C < A =
    {
      // Invalid.
      vtype delegatee_type = D2;
    }

FIXME: Continue.


* Lookup

The process of retrieving a virtual type given a class (``source'')
and a type name (``target'') is call ``virtual type lookup''.  We'll
use a has (or pound) symbol (#) to  a virtual type lookup.

  Ex.:

    class A < stc::none =
    {
      vtype foo = int;
    }

    // t contains the value of the virtual type foo from class A.
    type t = A#foo;

** Local lookup

Recall: The lookup process is recursive: it starts from a class (a
priori concrete).

This process relies on an `atomic' lookup on each inspected class:
each of them can be queried for a locally defined virtual type.
(FIXME: reference to the local_find algorithm.)

The result of this local lookup is
- mlc::not_found: meaning there is no delegatee_type;
- another C++ type: this is then  the result of the lookup;
- a compile-time error (mlc::assert or mlc::abort), meaning that
  something is either wrong in the virtual type definitions or in the
  query.


** General virtual type lookup

When looking for a virtual type from a class, the answer can come from
- the class itself, if it directly defines the virtual type;
- one of its super classes (``the inheritance branch'');
- if applicable, its delegatee, or one of its super classes (``the
  delegation branch'').


So, the lookup is performed in a single or a double (if there is a
delegatee) recursive search up from the class in the inheritance and
the delegation branch (if applicable).


Teh first step in the lookup is to find whether a local definition of
the virtual type (i.e., within the ``source'' class) exists. (See item
``Local lookup''). If so, it is returned.

If (FIXME: Finish this sentence.)


FIXME: Do we want to perform the checks of the inheritance and
delegation branch (in that event).

Then, a delegatee_type is looked for.  The result of this search can
be either
- stc::not_found: meaning there is no delegatee_type;
- another C++ type: this is then  the result of the lookup;
- a compile-time error (mlc::assert or mlc::abort), meaning that
  something is either wrong in the virtual type definitions or in the
  query.

Note: the general lookup procedure (either for delegatee_type or any
other other virtual type) return stc::not_found when it fails to find
the target virtual type, whereas the local lookup return
mlc::not_found.




FIXME: Continue.

*** stc::not_delegated

Cannot appear in a class of the delegation branch (aside from the
junction class).

*** Abstract

[...]

stc::abstract in a delegation branch:

  class A < stc::none
  {
    // my_vtype not defined.
  }

  class D < stc::none
  {
    vtype my_type = 0;
  }

  // A
  // ^
  // |
  // C<>--D
  class C < stc::none
  {
    vtype delegatee_type = D;
  }

  // Gives stc::not_found.
  type t = C#my_type;


** delagatee_type lookup

The lookup of delegatee_type is different from the lookup of other
virtual types.  While other virtual types are searched for in both the
inheritance and the delegation branch, delegatee_type is only seeked
in the inheritance branch (for infinite recursion reasons).

FIXME: Continue.


*** Abstract

FIXME: Continue.

* Examples


** A complex example

       A
       ^
       |    X
       B    ^
       ^    |
       |    Y
       C<>-´
       ^
       |
       D
       ^
       |
       E

  class A < stc::none
  {
  }
  class B < A
  {
    vtype foo = 0;
  }

  class X < stc::none
  {
    vtype bar = 0;
    vtype hop = int;
  }
  class Y < X
  {
    vtype bar = char;
    vtype baz = short;
  }

  class C < B
  {
    vtype delegatee_type = Y;
    vtype foo = int;
    vtype baz = not_delegated;
    vtype hop = not_delegated;
  }
  class D < C
  {
    vtype quux = unsigned;
  }
  class E < D
  {
    vtype baz = float;
  }

*** E#bar

       A          local_find(A, bar) = mlc::not_found
       ^
       |
       |    X                                        local_find(X, bar) = 0
       |    ^
       |    |
       B    |     local_find(B, bar) = mlc::not_found
       ^    |
       |    |
       |    Y                                     local_find(Y, bar) = char
       |    |
       |    |
       C<>-´              local_find(D, bar) = mlc::not_found
       ^
       |
       D                  local_find(D, bar) = mlc::not_found
       ^
       |
       E                  local_find(E, bar) = mlc::not_found

*** E#hop

       A          local_find(A, bar) = mlc::not_found
       ^
       |    X
       B    ^     local_find(B, bar) = mlc::not_found
       ^    |
       |    Y
       C<>-´              local_find(D, bar) = stc::not_delegated
       ^
       |
       D                  local_find(D, hop) = mlc::not_found
       ^
       |
       E                  local_find(E, hop) = mlc::not_found



Local Variables:
ispell-local-dictionary: "american"
End:

SCOOP 2 - algorithms						-*- outline -*-

These algorithms are expressed in a pseudo-Caml like syntax.


===========================================================================
* Preamble

Notes:

- syntax: foo#super returns the type of the super class of foo.

- syntax: 'foo_type' stands for the SCOOP virtual type named foo_type.

- stc::none#super is an error, but calling `find (none, ...)' returns
  stc::not_found.


===========================================================================
* Top-down approach

These algorithms have been prototyped in algorithms.ml.

** find

function find (source, target, string) =
  let res = find_rec (source, target) in
  match res with
    | stc::abstract               -> error "find: VT is abstract."
    | stc::not_delegated_abstract -> error "find: VT is abstract."
    | stc::not_delegated          -> stc::not_found
    | stc::final t                -> t
    | t                           -> t


** find_rec

function find_rec (source, target) =
  if (source = mlc::none)
    stc::not_found
  else
    let local_res = find_local (source, target) in

    let super_res = find_rec (source#super, target) in
    /* FIXME: This might not be efficient, since find_rec can be
       called several times on the nodes of the delegation branch when 
       going down the inheritance branch.  Of course, the declarative
       nature of C++ templates will avoid this cost, but it might be
       inelegant -- I'm not sure).  */
    let delegatee = find_rec_in_supers (source, 'delegatee_type') in
    let delegatee_res = 
      match delegatee with
      | stc::not_found -> stc::not_found
      | stc::abstract  -> stc::not_found
      | _              -> find_rec delegatee target in

    merge3 (local_res, super_res, delegatee_res)


// Like find_rec, but only search in the inheritance branch.
function find_rec_in_supers (source, target) =
  if (source = mlc::none)
    stc::not_found
  else
    let local_res = find_local (source, target) in
    let super_res = find_rec (source#super, target) in
    merge2 (local_res, super_res)


merge2 (local_res, super_res) =
  match local_res, super_res with

  | stc::abstract,  stc::not_found -> stc::abstract
  | mlc::not_found, stc::not_found -> stc::not_found
  | T,              stc::not_found -> T
  | stc::final<T>,  stc::not_found -> stc::final<T>

  | mlc::not_found, stc::abstract -> stc::not_found
  | stc::abstract,  stc::abstract -> stc::abstract
  | T,              stc::abstract -> T
  | stc::final<T>,  stc::abstract -> stc::final<T>

  | stc::abstract,  U              -> error ("VT redefined abstract.")
  | mlc::not_found, U              -> U
  | T,              U              -> T
  | stc::final<T>,  U              -> stc::final<T>

  | stc::abstract,  stc::final<U>  -> error ("Final VT redefined abstract")
  | mlc::not_found, stc::final<U>  -> stc::final<U>
  | T,              stc::final<U>  -> error ("Final VT redefined.")
  | stc::final<T>,  stc::final<U>  -> error ("Final VT redefined final.")


merge3 (local_res, super_res, delegatee_res) =
  match local_res, super_res, delegatee_res with

  // local_res == stc::not_found.
  | mlc::not_found, stc::not_found, stc::not_found -> stc::not_found
  | mlc::not_found, stc::not_found, stc::abstract  -> stc::not_found
  | mlc::not_found, stc::not_found, stc::final<V>  -> stc::final<V>
  | mlc::not_found, stc::not_found, V              -> V

  | mlc::not_found, stc::abstract,  stc::not_found -> stc::not_found
  | mlc::not_found, stc::abstract,  stc::abstract  -> stc::abstract
  | mlc::not_found, stc::abstract,  stc::final<V>  -> stc::final<V>
  | mlc::not_found, stc::abstract,  V              -> V

  | mlc::not_found, stc::final<U>,  _              -> stc::final<U>
  | mlc::not_found, U,              _              -> U


  // local_res == stc::not_abstract.
  | stc::abstract,  stc::not_found, stc::not_found -> stc::abstract
  | stc::abstract,  stc::not_found, stc::abstract  -> stc::abstract
  | stc::abstract,  stc::not_found, stc::final<V>  -> stc::final<V>
  | stc::abstract,  stc::not_found, V              -> V

  | stc::abstract,  stc::abstract,  stc::not_found -> stc::abstract
  | stc::abstract,  stc::abstract,  stc::abstract  -> stc::abstract
  | stc::abstract,  stc::abstract,  stc::final<V>  -> stc::final<V>
  | stc::abstract,  stc::abstract,  V              -> V

  | stc::abstract,  stc::not_delegated_abstract, _ -> stc::not_delegated_abstract
  | stc::abstract,  stc::not_delegated, _          -> stc::not_delegated_abstract

  | stc::abstract,  stc::final<U>,  _              -> error ("Final VT "
                                                        "redefined abstract")
  | stc::abstract,  U,              _              -> error ("VT redefined "
                                                        "abstract.")
  // local_res == stc::not_delegated.
  | stc::not_delegated,  stc::not_found, _         -> stc::not_delegated
  | stc::not_delegated,  stc::abstract,  _         -> stc::not_delegated_abstract
  | stc::not_delegated,  stc::not_delegated_abstract, _ -> stc::not_delegated_abstract

  // local_res == stc::not_delegated_abstract.
  /* FIXME: Shouldn't we introduce a means to tag a vtype both
     as abstract *and* not delegated?  (Currently, the rule below
     prevents this).  */
  | stc::not_delegated_abstract, _, _              -> error ("Local "
                                                             "declaration of "
                                                             "not delegated " 
							     "and abstract")

  // local_res == stc::final<T>.
  | stc::final<T>,  stc::final<U>,  _              -> error ("Final VT "
                                                        "redefined final.")
  | stc::final<T>,  _,              _              -> stc::final<T>

  // local_res == T.
  | T,              stc::final<U>,  _              -> error ("Final VT "
                                                        "redefined.")
  | T,              _,              _              -> T




===========================================================================
* Bottom-up approach (FIXME: not finished, and old)

This implementation doesn't handle stc::not_delegated properly.

** find_local 

fun find_local (source, target) =
  mlc::get_typedef (source, target)

(get_typedef is a routine from Metalic.)


** find

// FIXME: Handle final.

fun find (source, target) =
  if (source == stc::none)
    error ("find: cannot perform lookup on stc::none.") // FIXME: Detail.
  else
    let local_type = find_local (source, target) in
    let delegatee_type = find_local (source, 'delegatee_type') in

    match local_type with

    | stc::abstract -> error ("find: abstract virtual type in leaf class.")

    | stc::no_delegation ->
	// Look only in the inheritance branch only.
	find_rec (source#super, target)

    | mlc::not_found ->
	if (delegatee_type = mlc::not_found)
	  // Look only in the inheritance branch only.
	  find_rec (source#super, target)
	else
	  let inheritance_branch_res = find_rec (source#super, target) in
	  let delegation_branch_res = find_rec (delegatee_type, target) in
	  merge (inheritance_branch_res, delegation_branch_res)

    | T -> T


** find_rec0

(Previous version of find_rec.)

fun find_rec0 (source, target, is_abstract = false) =
  let local_type = find_local (source, target) in

  match local_type, source#super, is_abstract with

  | stc::not_delegated,  _        , _     ->
      error ("find_rec: stc::delegation found in non-leaf class.")

  | mlc::not_found,      mlc::none, _     -> stc::not_found
  | mlc::not_found,      S        , _     -> find_rec (S, target, is_abstract)

  | stc::abstract,       mlc::none, _     -> stc::abstract
  | stc::abstract,       S        , _     -> find_rec (S, target, true)

  // Final<T> is handled like T (the checks are performed elsewhere).
  | stc::final<T>,       _,         false  -> T
  | stc::final<T>,       _,         true   ->
      error ("find_rec: virtual type redefined abstract.")

  | T,                   _,         false  -> T
  | T,                   _,         true   ->
      error ("find_rec: virtual type redefined abstract.")


** find_rec

FIXME: Improve the automaton of the states (abstract, defined, final,
etc.)

fun find_rec (source, target, res = stc::not_found) =
  if (source = mlc::none)
    res
  else
    let local_type = find_local (source, target) in

    match local_type, res with

    | stc::not_delegated,  _ ->
	error ("find_rec: stc::delegation found in non-leaf class.")

    | mlc::not_found,      _ -> find_rec (source#super, target, res)

    // The values below cannot be used to redefine a *final* virtual type.

    | stc::abstract,       _ -> find_rec (source#super, target, stc::abstract)

    | T,                   _ -> T
        match res with
        | stc::not_found -> find_rec (source#super, target, T)
        | stc::abstract  ->
            // FIXME: Detail
            error ("find_rec: virtual type redefined as abstract.")
        | _ -> find_rec (source#super, target, T)

    // stc::final<T> is handled like T, with additional checks.
    | stc::final<T>,       _ ->
        match res with
        | stc::not_found -> find_rec (source#super, target, T)
        | stc::abstract  ->
            // FIXME: Detail
            error ("find_rec: final virtual type redefined as abstract.")
        | _ -> error ("find_rec: final virtual type redefined.")


FIXME: Write another version where the search is performed top-down
(in both branches).  Handling the lookup this way seems to ease the
writing of states and automata.

** merge

fun merge (inheritance_branch_res delegation_branch_res) =
  match (inheritance_branch_res, delegation_branch_res)
  | stc::not_found, stc::not_found -> stc::not_found
  | stc::not_found, stc::abstract  -> stc::not_found
  | stc::not_found, U              -> U

  | stc::abstract,  stc::not_found -> error () // FIXME: Detail.
  | stc::abstract,  stc::abstract  -> error () // FIXME: Detail.
  | stc::abstract,  U              -> U

  | T,              _              -> T

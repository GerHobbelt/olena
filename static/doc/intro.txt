Static - Equipment for Static Hierarchies and SCOOP 2		-*- outline -*-

This a very rough, buggy and incomplete draft of explanations on
SCOOP 2.  To be improved, fixed, and completed!


* On virtual types

A description of the mechanism of virtual types in SCOOP 2.

** Rules

A virtual type is like a typedef in a class scope, with added
possibilities.  Like a method (in C++),
- it can be abstract (i.e., only declared, with a postponed
  definition, to be given in a concrete subclass);
- it can be altered;
- it is resolved (looked up for) bottom-up.

SCOOP 2 describes a virtual type pattern where virtual types are
declared and (re-)defined across a class hierarchy (thanks to the
``super'' relationship), but also across a (single) delegation
relationship.

*** Virtual type name declaration

The SCOOPed namespace must be equipped for every virtual type name.

*** Class virtual types.

- Each class can define any number of virtual types. Some of them
  have a special meaning (see below):

  - delegatee_type
  - (supertype ?)

  Some ``values'' (i.e., type assigned to the typedef standing for a
  vtype) have a special meaning (see below):

  - stc::abstract
  - stc::final<T>
  - stc::not_found
  - stc::not_delegated

*** Single inheritance

**** Class definition
				  A
				  ^
				  |
				  B

- A class *must* declare another class as being its superclass.  When A
  is a superclass of B, B is said to be a direct subclass or direct
  derived class of A.  Every subclass of B an (indirect) subclass or
  (indirect) derived class of A.

  Ex.:

    A < B
    {
      // ...
    }

  When a class has semantically no superclass, its superclass must
  be set to stc::none.  A class having no supertype is invalid.

  Ex.:

    // Valid.
    A < stc::none
    {
      // ...
    }

    // Invalid.
    A
    {
      // ...
    }

- A virtual defined as stc::final<T> in a class cannot be redefined
  in any of its derived class(es).

- A (non final) virtual type defined in a class can be redefined in any
  of its subclasses.

- A vtype can be /declared/ as stc::abstract. Such a definition is
  actually a making it a virtual declaration, meaning that an actual
  type definition is required in a concrete subclass of the class
  where this vtype was declared abstract, for this subclass to be
  instantiable.

  To put it in a nutshell: a valid virtual type cannot resolve as
  stc::abstract.

**** Virtual type look-up
  
- The process of resolving a vtype involves a source (a class) and a
  vtype (a typedef).  If both the structures involved and the request
  are valid, the result of this operation is

  - a typedef, if the resolution succeeded;
  - mlc::not_found.

  Note that a source must be a *concrete* class.

FIXME: Describe how the look-up works here.

- A virtual type can resolve as mlc::not_found, if the queried class
  doesn't have a value for this vtype (cf. supra).

*** Single inheritance + single Delegation

				A
				^
				|
				C<>--D

- A class can have a special vtype named `delegatee_type', whose value
  refers to another class name.  The latter class will be a delegation
  of the former class.

- Prone to discussion:
  The `delegatee_type' vtype is not looked up like other vtypes,
  instead, only the considered concrete class is queried -- no
  superclass is involved in this process.

    Note: in Théo's implementation of stc/scoop.hh (revision 712 in
    the Olena repository), the `delegatee_type' vtype *is* looked up
    throughout the super classes of the `from' class.  Obviously, this
    look-up doesn't occur not in the delegation branch!

- The rules of the vtype look-up are affected by the presence of a
  delegation.  The default global rule is: unless defined in the
  current class, a vtype if looked in the superclass branch first, then
  in the delegation branch.

FIXME: False.
- The look-up w.r.t. stc::final<T> remains the same, but is performed
  in the supertype branch and the delegation branch (if applicable).

- When the vtype is defined in the class where it is looked for,
  this value is returned.

  Exception: if this typedef has value stc::not_delegated, the result
  of the look-up is the same as if there was
  - no delegation,
  - no definition for this vtype in the considered class,
  i.e., the result is computed from the superclass branch *only*.


  When the vtype if not defined in the class, the look-up is done in
  parallel, in the superclass branch and in the delegation branch.  If
  no error has arisen during theses (internal) look-ups, two typedefs
  are returned (one for each branch).  The final result of the overall
  look-up is the result of a merge of the two typedefs, whose rules are
  given by the following table.

FIXME: For Olena 1.0, we'll consider that a vtype in the delegation
branch cannot be stc::abstract.

    +------------------------------+-----------------------------------------+
    |                              |   result of the delegation branch       |
    |                              +----------------+----------------+-------+
    |                              |                | stc::abstract  |       |
    |                              | stc::not_found |  (error must   | U [2] |
    |                              |                | not occur [1]) |       |
    +-------------+----------------+----------------+----------------+-------+
    | result of   | stc::not_found | stc::not_found | stc::not_found |   U   |
    | the look-up +----------------+----------------+----------------+-------+
    | in the      | stc::abstract  |      error     |     error      |   U   |
    | superclass  +----------------+----------------+----------------+-------+
    | branch      |     T [2]      |        T       |       T        |   T   |
    +-------------+----------------+----------------+----------------+-------+

    Notes:
    [1]    The main idea being: delegation is additional material.  Note
           that we could have chosen the other convention

           FIXME: Should there be error when the inheritance branch
	   answers stc::not_found and the delegation branch answers
	   stc::abstract?

    [2]    T and U are two types different from stc::not_found and
           stc::abstract.


* A bit of formalism

** Types and algorithms signatures

*** Built-in values

cxx_type_name			// any valid C++ type
cxx_class_name :: cxx_type_name	// a C++ class/struct

*** SCOOP2 values

vtype_name :: cxx_type_name
scooped_class_name :: cxx_class_name


find :: scooped_class_name, vtype_name -> cxx_type_name





---------------------------------------------------------------------------
* Open questions on this document, things to do, etc.

In all these questions, we assume that A is a superclass of B.
Let A be a superclass of B.

- Can a vtype defined in A as concrete, be redefined in B as
  stc::abstract? (at least not for Olena 1.0).

- Can a virtual defined as stc::final<T> in a class A cannot be
  ``redefined'' as stc::final<T> (i.e., the exact same type) in a
  derived classed B?  (No.)

- Can a virtual type be assigned the type stc::not_found?

- Is there a `exact_type' vtype?  If so, does it have to be present in
  every class?


** Lookup Strategies

*** Bottom-up, with fork at junction and merge of both results.
Current strategy, half-designed in algorithm.txt.

*** Top-down from each top class, with merge at junction.
To be tried/written.


*** Linear top-down (?)
The walk in the delegation branch is performed between the upper part
(above the junction) and the lower part (below the junction).

*** Linear bottom-up (?)
The walk in the delegation branch is performed between the lower
part (below the junction) and the upper part (above the junction).

*** Anything else (?)



** Rule enforcement (virtual types checking)

*** Ensuring the vtype name is known (i.e., declared in the SCOOPed namespace 

*** Existence of a superclass

*** Absence/uniqueness of a delegation

*** Checking Final vtypes

(In both branches, if applicable.)

*** Ensuring that the vtype is not abstract


** Check algorithm

// FIXME: To do.

** Look-up algorithm

  /** Virtual type look-up.
 
      \a source is the (concrete) class from which the look-up is performed
      \a target is the name of the virtual type looked for (without
                the `_type' suffix).  */
  find :: scooped_class, 
  find(source, target)

    // FIXME: Write algorithm.

---------------------------------------------------------------------------





Local Variables:
ispell-local-dictionary: "american"
End:

 LocalWords:  typedef SCOOPed namespace delegatee supertype vtype superclass
 LocalWords:  instantiable vtypes Théo's stc typedefs ispell american
